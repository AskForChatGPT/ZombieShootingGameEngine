<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多人僵尸迷宫射击游戏 - 增强版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
            padding: 15px;
            background: rgba(26, 35, 53, 0.8);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid #3498db;
        }
        
        h1 {
            color: #e74c3c;
            font-size: 2.5rem;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
            letter-spacing: 1px;
            background: linear-gradient(to right, #e74c3c, #f1c40f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            color: #3498db;
            font-size: 1.2rem;
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }
        
        .canvas-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 3px solid #7f8c8d;
            background-color: #2a2a2a;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.8);
            border-radius: 5px;
        }
        
        .controls-section {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
        }
        
        #controls {
            background: rgba(44, 62, 80, 0.8);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            width: 100%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        
        .controls-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(127, 140, 141, 0.3);
        }
        
        .controls-group:last-child {
            border-bottom: none;
        }
        
        .controls-group h3 {
            color: #3498db;
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.2rem;
        }
        
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        input, button, select {
            background-color: #34495e;
            color: #ecf0f1;
            border: 1px solid #2c3e50;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        input {
            width: 70px;
            text-align: center;
        }
        
        input:focus, button:hover, select:hover {
            background-color: #3d566e;
            border-color: #3498db;
            outline: none;
        }
        
        button {
            cursor: pointer;
            min-width: 120px;
            flex: 1;
        }
        
        button:active {
            transform: translateY(2px);
        }
        
        .primary-btn {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            font-weight: bold;
        }
        
        .danger-btn {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            font-weight: bold;
        }
        
        .success-btn {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            font-weight: bold;
        }
        
        .warning-btn {
            background: linear-gradient(to bottom, #f39c12, #d35400);
            font-weight: bold;
        }
        
        .weapon-info {
            background: rgba(34, 34, 34, 0.9);
            padding: 15px;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            margin-top: 15px;
            border: 1px solid #7f8c8d;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        
        .weapon-info h3 {
            color: #f1c40f;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .weapon-stats {
            display: flex;
            justify-content: space-around;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #3498db;
        }
        
        .instructions {
            background: rgba(44, 62, 80, 0.8);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            width: 100%;
            max-width: 900px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        
        .instructions h3 {
            color: #3498db;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3rem;
        }
        
        . instructions-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .instructions-col {
            flex: 1;
            min-width: 250px;
        }
        
        .instructions ul {
            padding-left: 20px;
            text-align: left;
        }
        
        .instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .key {
            display: inline-block;
            background: #2c3e50;
            padding: 3px 10px;
            border-radius: 4px;
            border: 1px solid #7f8c8d;
            font-family: monospace;
            margin: 0 2px;
            font-weight: bold;
            color: #f1c40f;
        }
        
        .zombie-info {
            color: #2ecc71;
            font-weight: bold;
        }
        
        .save-load-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .save-load-btn {
            flex: 1;
            min-width: 140px;
        }
        
        .json-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        
        textarea {
            width: 100%;
            height: 100px;
            background: #2c3e50;
            color: #ecf0f1;
            border: 1px solid #34495e;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            resize: vertical;
        }
        
        .status-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .success-message {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            border: 1px solid #27ae60;
        }
        
        .error-message {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid #c0392b;
        }
        
        .info-message {
            background: rgba(52, 152, 219, 0.2);
            color: #3498db;
            border: 1px solid #2980b9;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #e74c3c;
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            border: 3px solid #e74c3c;
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.7);
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(231, 76, 60, 0.7); }
            50% { box-shadow: 0 0 30px rgba(231, 76, 60, 0.9); }
            100% { box-shadow: 0 0 15px rgba(231, 76, 60, 0.7); }
        }
        
        .game-over button {
            margin-top: 20px;
            font-size: 1rem;
            padding: 10px 25px;
        }
        
        .hidden {
            display: none;
        }
        
        .player-info {
            background: rgba(34, 34, 34, 0.9);
            padding: 15px;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            margin-top: 15px;
            border: 1px solid #7f8c8d;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        
        .player-info h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .players-stats {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        .player-stat {
            background: #2c3e50;
            padding: 8px;
            border-radius: 6px;
            min-width: 80px;
        }
        
        .player-stat.active {
            border: 2px solid #f1c40f;
            background: #34495e;
        }
        
        .player-stat.dead {
            opacity: 0.6;
            textAIRobot: text-decoration: line-through;
        }
        
        .player-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .player-health {
            font-size: 0.9rem;
            color: #e74c3c;
        }
        
        footer {
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9rem;
            text-align: center;
            width: 100%;
            padding: 15px;
        }
        
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .controls-section {
                width: 100%;
            }
            
            canvas {
                width: 100%;
                max-width: 500px;
                height: auto;
            }
        }

        /* New CSS for button container and buttons */
#buttonContainer {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 1000; /* Ensure above canvas */
    display: none; /* Hidden by default, toggled by JS */
}

#buttonContainer button {
    display: block;
    margin-bottom: 10px;
    padding: 8px 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

#buttonContainer button:hover {
    background-color: #45a049;
}

/* 確保按鈕是可點擊的 */
#placeLickerBtn {
    background: linear-gradient(to bottom, #e74c3c, #9b59b6);
    font-weight: bold;
    color: white;
    border: none;
    padding: 8px 15px;
    margin: 5px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
}

#placeLickerBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#placeAmmoDepot {
    background-color: #e67e22;
    color: white;
}

#placeAmmoDepot:hover {
    background-color: #d35400;
}
    </style>
</head>
<body>
    <div class="header">
        <h1>多人僵尸迷宫射击游戏</h1>
        <p class="subtitle">建造迷宫 - 放置敌人和玩家 - 生存下来</p>
    </div>
    
    <div class="game-container">
        <div class="canvas-section">
            <canvas id="gameCanvas"></canvas>
            
            <div id="weaponInfo" class="weapon-info hidden">
                <h3>武器狀態</h3>
                <div class="weapon-stats">
                    <div class="stat">
                        <div>模式</div>
                        <div id="weaponMode" class="stat-value">手枪</div>
                    </div>
                    <div class="stat">
                        <div>弹匣</div>
                        <div id="currentAmmo" class="stat-value">10</div>
                    </div>
                    <div class="stat">
                        <div>弹药</div>
                        <div id="totalAmmoDisplay" class="stat-value">50</div>
                    </div>
                    <div class="stat">
                        <div>手榴彈</div>
                        <div id="grenadeCountDisplay" class="stat-value">3</div>
                    </div>
                </div>
            </div>
            
            <div id="playerInfo" class="player-info hidden">
                <h3>玩家状态</h3>
                <div class="players-stats" id="playersStats"></div>
            </div>
        </div>
        
        <div class="controls-section">
            <div id="controls">
                <div class="controls-group">
                    <h3>游戏设置</h3>
                    <div class="controls-row">
                        <label>网格尺寸: <input type="number" id="gridSize" value="50" min="10" max="2000"></label>
                        <button id="startSetup" class="primary-btn">开始设置</button>
                    </div>
                </div>
                
                <div id="setupControls" class="hidden">
                    <div class="controls-group">
                        <h3>放置对象</h3>
                        <div class="controls-row">
                            <button id="placeAmmoDepot" class="primary-btn">放置彈藥庫</button>
                            <button id="placeTeleport" class="primary-btn">放置傳送點</button>
                            <button id="placePlayer" class="primary-btn">放置玩家</button>
                            <button id="placeWall" class="primary-btn">放置墙壁</button>
                            <button id="placeLineWall" class="primary-btn">直線牆</button>
                            <button id="placeCurveWall" class="primary-btn">曲線牆</button>
                            <button id="placeRectWall" class="primary-btn">矩形墙壁</button>
                            <button id="placeDoor" class="primary-btn">放置门</button>
                            <button id="placeWindow" class="primary-btn">放置窗</button>
                        </div>
                        <div class="controls-row">
                            <button id="placeEnemy" class="danger-btn">放置敌人</button>
                            <button id="placeZombie" class="success-btn">放置僵尸</button>
                            <button id="placeLickerBtn">放置Licker</button>
                            <button id="removeItem" class="warning-btn">移除物品</button>
                            <button id="removeEntity" class="warning-btn">移除人物</button>
                        </div>
                        <div class="controls-row">
                            <button id="placeDefenseArea" class="warning-btn">放置攻防区域</button>
                        </div>
                    </div>
                    
                    <div class="controls-group">
                        <h3>武器設置</h3>


                        <div class="controls-row">
                            <label>彈匣容量: <input type="number" id="magazineSize" value="19" min="1" max="2000"></label>
                            <label>總彈藥量: <input type="number" id="totalAmmo" value="296" min="1" max="500"></label>
                            <label>手榴彈數量: <input type="number" id="grenadeCount" value="4" min="0" max="10"></label>
                        </div>
                            <!-- 新增武器速度倍數控制 -->
    <div class="controls-row">
        <label>武器速度倍數: 
            <input type="number" id="weaponSpeedMultiplier" value="0.5" min="0.01" max="10" step="0.01">
        </label>
    </div>
                    </div>

                    <div class="controls-group">
                        <h3>敌人设置</h3>
                        <div class="controls-row">
                            <button id="setEnemyPath" class="warning-btn">设置敌人路径</button>
                            <!--  <button id="confirmPathBtn" class="tool-button">✓ 確認當前路徑</button> -->
                        </div>
                    </div>
                    
                    <div class="controls-group">
                        <h3>游戏控制</h3>
                        <div class="controls-row">
                            <button id="startGame" class="success-btn">开始游戏</button>
                        </div>
                    </div>
                    
                    <div class="controls-group">
                        <h3>地图管理</h3>
                        <div class="save-load-row">
                            <button id="saveMap" class="save-load-btn success-btn">保存地图</button>
                            <button id="loadMap" class="save-load-btn primary-btn">加载地图</button>
                        </div>
                        <div class="json-controls">
                            <button id="exportMap" class="save-load-btn warning-btn">导出地图JSON</button>
                            <button id="importMap" class="save-load-btn primary-btn">导入地图JSON</button>
                            <textarea id="jsonData" placeholder="在此粘贴地图JSON数据..."></textarea>
                        </div>
                    </div>
                    
                    <div id="statusMessage" class="status-message"></div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>游戏说明</h3>
                <div class="instructions-content">
                    <div class="instructions-col">
                        <ul>
                            <li><strong>玩家移动</strong>: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span></li>
                            <li><strong>射击模式</strong>: 手枪模式 <span class="key">1</span> | 自动模式 <span class="key">2</span></li>
                            <li><strong>射击</strong>: 鼠标左键 | 自动射击 <span class="key">X</span></li>
                            <li><strong>开门</strong>: 靠近门按 <span class="key">F</span></li>
                            <li><strong>投掷手雷</strong>: 按住 <span class="key">G</span> 瞄准后释放</li>
                        </ul>
                    </div>
                    <div class="instructions-col">
                        <ul>
                            <li><strong>重新装弹</strong>: <span class="key">R</span></li>
                            <li><strong>保存/加载地图</strong>: 使用地图管理按钮</li>
                            <li><span class="zombie-info">绿色僵尸</span> 速度是玩家的3倍，碰到你会结束游戏！</li>
                            <li>所有敌人视觉范围增加5倍（但不会透视墙壁）</li>
                            <li>可放置多名玩家，角色死亡后切换到下一个玩家</li>
                            <li>所有玩家共享总弹药量</li>
                            <li><span style="color: #f1c40f;">攻防区域</span> 僵尸进入该区域会立即结束游戏！</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameOver" class="game-over hidden">
        <div>游戏结束!</div>
        <div id="gameOverReason"></div>
        <button id="restartGame" class="danger-btn">重新开始</button>
    </div>
    
    <footer>
        多人僵尸迷宫射击游戏 © 2023 | 使用HTML5 Canvas开发
    </footer>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSizeInput = document.getElementById('gridSize');
        const startSetupBtn = document.getElementById('startSetup');
        const setupControls = document.getElementById('setupControls');
        const placePlayerBtn = document.getElementById('placePlayer');
        const placeWallBtn = document.getElementById('placeWall');
        const placeLineWallBtn = document.getElementById('placeLineWall');
        const placeCurveWallBtn = document.getElementById('placeCurveWall');
        const placeRectWallBtn = document.getElementById('placeRectWall');
        const placeDoorBtn = document.getElementById('placeDoor');
        const placeEnemyBtn = document.getElementById('placeEnemy');
        const placeZombieBtn = document.getElementById('placeZombie');
        const placeLickerBtn = document.getElementById('placeLickerBtn'); // 新增這行
        const removeItemBtn = document.getElementById('removeItem');
        const placeDefenseAreaBtn = document.getElementById('placeDefenseArea');
        const startGameBtn = document.getElementById('startGame');
        const setEnemyPathBtn = document.getElementById('setEnemyPath');
        const weaponModeDisplay = document.getElementById('weaponMode');
        const currentAmmoDisplay = document.getElementById('currentAmmo');
        const totalAmmoDisplay = document.getElementById('totalAmmoDisplay');
        const weaponInfo = document.getElementById('weaponInfo');
        const playerInfo = document.getElementById('playerInfo');
        const playersStats = document.getElementById('playersStats');
        const magazineSizeInput = document.getElementById('magazineSize');
        const totalAmmoInput = document.getElementById('totalAmmo');
        const saveMapBtn = document.getElementById('saveMap');
        const loadMapBtn = document.getElementById('loadMap');
        const exportMapBtn = document.getElementById('exportMap');
        const importMapBtn = document.getElementById('importMap');
        const jsonDataTextarea = document.getElementById('jsonData');
        const statusMessage = document.getElementById('statusMessage');
        const gameOverScreen = document.getElementById('gameOver');
        const gameOverReason = document.getElementById('gameOverReason');
        const restartGameBtn = document.getElementById('restartGame');
        const removeEntityBtn = document.getElementById('removeEntity');
        const visionRange = 25; // 玩家視覺範圍半徑（25格 = 50x50的視覺範圍）
        const visionAngleDegrees = 80; // 單邊視角80度 (總共160度視野)
        const visionAngleRadians = visionAngleDegrees * (Math.PI / 180); // 轉換為弧度
        const viewportWidth = 150*0.8;  // 視窗寬度（格數）
        const viewportHeight = 50*0.8; // 視窗高度（格數）
        const placeWindowBtn = document.getElementById('placeWindow');
        const placeTeleportBtn = document.getElementById('placeTeleport');
        const visionGridSize = 15; // 將視覺檢測區域分割為10x10的網格
        // 在遊戲設置部分添加敵人視覺參數
        const enemyVisionRange = visionRange / 2; // 視力範圍減半
        const enemyVisionAngle = Math.PI * 160 / 180; // 160度視角
        // 在遊戲設置部分添加敵人視覺繪製參數
        const enemyVisionColor = 'rgba(255, 0, 0, 0.15)'; // 半透明紅色
        const enemyVisionBorderColor = 'rgba(255, 100, 100, 0.3)'; // 視覺邊界線顏色
        // 在全局變量後添加對輸入框的引用
        const weaponSpeedMultiplierInput = document.getElementById('weaponSpeedMultiplier');
        // 獲取按鈕元素
        const placeAmmoDepotBtn = document.getElementById('placeAmmoDepot');


// 在 ENEMY_TYPES 定義後添加 Licker 的移動相關常數
const LICKER_MOVEMENT = {
    IDLE: 0,
    WANDERING: 1,
    CHASING: 2
};



const ENEMY_TYPES = {
    ZOMBIE: 'zombie',
    SHOOTER: 'shooter',
    LICKER: 'licker'
};

        // 建立空間網格系統
const SPATIAL_GRID_SIZE = 5; // 每個網格5x5單位
const spatialGrid = {};
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            x: false,
            t: false
        };

        // 實驗這些值找到最佳平衡
const ZOMBIE_SETTINGS = {
    baseSpeed: 0.05,  // 增加基礎速度
    visionRange: 5,
    separationRadius: 2.5,  // 減少分離半徑
    personalSpace: 0.8,     // 減少個人空間
    maxSeparationForce: 0.4 // 減少最大分離力
};

const PLAYER_SETTINGS = {
    collisionRadius: 0.4, // 略小於吃掉距離
    eatDistance: 0.5      // 適當增加確保可靠觸發
};

        let cameraOffset = { x: 0, y: 0 }; // 攝像機偏移量
        let savedPlayers = null;


        let gridSize = 50;
        let cellSize = 10;
        let grid = [];
        let players = [];
        let currentPlayerIndex = 0;
        let enemies = [];
        let defenseAreas = [];
        let bullets = [];
        let enemyBullets = [];
        let grenade = null;
        let gameState = 'setup';
        let currentPlacement = null;
        let aiming = false;
        let newKeys = { w: false, a: false, s: false, d: false, x: false, f: false };
        let savedGrid = null;
        let savedEnemies = null;
        let savedDefenseAreas = null;
        let isDragging = false;
        let rectStart = null;
        let settingEnemyPath = false;
        let currentPathEnemy = null;
        let enemyPathPoints = [];
        let mouseDown = false;
        let lastMousePos = { clientX: 0, clientY: 0 };
        let currentDefenseArea = null;
        let curveControlPoint = null;
        let curveDrawingState = 'none'; // 'none', 'drawing_line', 'adjusting_curve', 'finalized'
        let isEditMode = true; // 標記是否在編輯模式
        let testMode = false; // 測試模式標記
        let windows = []; // 儲存所有窗戶的位置和狀態
        let teleports = [];
        let currentTeleportColor = getRandomFluorescentColor();
        let placingTeleportA = true; // 標記當前正在放置A點還是B點
        let currentTeleportPairId = 0;
        let teleportPairs = {}; // 記錄每組傳送點的配對關係       
        let selectedTeleportGroup = null;
        let visionGrid = [];
        let currentCompanionCommandIndex = 0;
        // 新增全域武器速度比例變量
        let globalWeaponSpeedMultiplier = 0.5;
        // 儲存所有彈藥庫的位置
        let ammoDepots = [];

        const WINDOW_DURATION = 5000; // 窗戶被喪屍撞擊後持續時間(毫秒)

        let bulletSettings = {
            pistol: { range: 40, penetration: 1, speed: 2.5, magazineSize: 15, reloadTime: 1.5 },
            auto: { range: 12, penetration: 1, speed: 2.5, magazineSize: 30, reloadTime: 2 },
            shotgun: { range: 8, penetration: 2, speed: 1.5, magazineSize: 6, reloadTime: 1.5 },
            grenadeRange: 10,
            grenadeExplosionRadius: 2
        };

let backgroundImage = {
    img: null, // Image object
    x: 0,      // Position (grid units)
    y: 0,
    width: 0,  // Size (grid units)
    height: 0,
    isDragging: false,
    isLocked: false,
    dragStart: null // {x, y} for drag offset
};

        // 創建玩家物件
function createPlayer(x, y) {
    return {
        x: Math.floor(x) + 0.5,  // 確保放在格子中心
        y: Math.floor(y) + 0.5,  // 確保放在格子中心
        vx: 0,
        vy: 0,
        angle: 0, // 初始角度
        speed: 2/3,
        placed: true,
        weaponMode: 1, // 1: pistol, 2: auto, 3: shotgun
        ammo: bulletSettings.pistol.magazineSize,
        magazineSize: {
            pistol: bulletSettings.pistol.magazineSize,
            auto: bulletSettings.auto.magazineSize,
            shotgun: bulletSettings.shotgun.magazineSize
        },
        totalAmmo: parseInt(totalAmmoInput.value) || 50,
        grenadeCount: parseInt(document.getElementById('grenadeCount').value) || 3,
        health: 100,
        alive: true,
        lastShotTime: 0,
        shootRate: 200,
        isReloading: false,
        reloadStartTime: 0,
        reloadTime: {
            pistol: bulletSettings.pistol.reloadTime,
            auto: bulletSettings.auto.reloadTime,
            shotgun: bulletSettings.shotgun.reloadTime
        },
        canMove: true, // 新增移动状态
        canShoot: true, // 新增射击状态
        isSprinting: false,  // 是否正在衝刺
        stamina: 100,       // 體力值
        lastStaminaUpdate: 0, // 上次體力更新時間
        sprintSpeed: 4/3,   // 衝刺速度 (2倍於基礎速度)
        slowSpeed: 1/5,       // 新增慢速 (基礎速度的1/2)
        isTeleporting: false,  // 新增傳送冷卻狀態
        lastTeleportTime: 0,    // 新增最後傳送時間
        isCompanion: false, // 是否是同伴
        companionOf: null, // 跟隨的玩家ID
        companionTarget: null, // 同伴的目標位置
        companionAttackRange: 5, // 同伴攻擊範圍
        companionAttackCooldown: 0, // 同伴攻擊冷卻
        companionState: 'idle', // 同伴狀態: idle, moving, attacking
        companionFollowingDistance: 1.5, // 跟隨距離
        companionSpeed: 0.8, // 同伴移動速度 (比玩家稍慢)
        waitingForReturn: false,  // 新增等待返回狀態
    };
}

function updateCompanionSystem() {
    players.forEach(player => {
        if (player.isCompanion && player.alive) {
            updateCompanionBehavior(player);
        }
    });
}


function updateCompanionBehavior(companion) {
    if (shouldReleaseCompanion(companion)) {
        releaseCompanion(companion);
        return;
    }

    // 同時處理攻擊和移動
    const attackTarget = findNearestEnemyForCompanion(companion);
    if (attackTarget) {
        handleCompanionAttack(companion, attackTarget);
    }

    if (companion.companionTarget) {
        handleCompanionMovement(companion);
    } else {
        handleCompanionFollowing(companion);
    }
}

// 檢查是否需要釋放同伴（領導者死亡等情況）
function shouldReleaseCompanion(companion) {
    const leader = players.find(p => p === companion.companionOf);
    return !leader || !leader.alive;
}

// 釋放同伴（恢復自由狀態）
function releaseCompanion(companion) {
    companion.isCompanion = false;
    companion.companionOf = null;
    companion.hasIndependentTarget = false;
}

// 處理同伴攻擊行為
function handleCompanionAttack(companion, target) {
    companion.companionState = 'attacking';
    attackEnemy(companion, target);
    // 不再有 return 語句，讓函數執行完後可以繼續處理移動
}

// 處理同伴移動行為
function handleCompanionMovement(companion) {
    companion.companionState = 'moving';
    moveToTarget(companion);
    
    if (hasReachedTarget(companion)) {
        companion.waitingForReturn = true;  // 設置等待返回狀態
        companion.companionState = 'waiting';  // 新增等待狀態
    }
}


// 檢查是否已到達目標位置
function hasReachedTarget(companion) {
    if (!companion.companionTarget) return false;
    
    const dx = companion.companionTarget.x - companion.x;
    const dy = companion.companionTarget.y - companion.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    return distance < 0.5;
}

// 處理同伴跟隨行為
function handleCompanionFollowing(companion) {
    // 如果正在等待返回且按下了 'y' 鍵
    if (companion.waitingForReturn && keys.y) {
        companion.waitingForReturn = false;
        companion.hasIndependentTarget = false;
        companion.companionTarget = null;
        keys.y = false;  // 重置按鍵狀態
        return;
    }
    
    // 如果正在等待返回，不做任何移動
    if (companion.waitingForReturn) {
        return;
    }
    
    companion.companionState = 'idle';
    
    if (companion.hasIndependentTarget) {
        return;
    }
    
    const leader = determineFollowTarget(companion);
    followLeader(companion, leader);
}

function renderCompanionStatus() {
    players.forEach((player, index) => {
        if (player.isCompanion && player.waitingForReturn) {
            // 在同伴上方顯示等待提示
            ctx.fillStyle = 'yellow';
            ctx.fillText('按 Y 返回', player.x, player.y - 20);
        }
    });
}



// 決定同伴應該跟隨的目標（玩家或其他同伴）
function determineFollowTarget(companion) {
    const leader = players.find(p => p === companion.companionOf);
    const directCompanions = getDirectCompanions(leader);
    
    if (directCompanions.length > 1) {
        const companionIndex = directCompanions.indexOf(companion);
        if (companionIndex > 0) {
            const previousCompanion = directCompanions[companionIndex - 1];
            if (previousCompanion && !previousCompanion.hasIndependentTarget) {
                return previousCompanion;
            }
        }
    }
    
    return leader;
}

// 獲取所有直接跟隨指定領導者的同伴
function getDirectCompanions(leader) {
    return players.filter(p => 
        p.isCompanion && 
        p.companionOf === leader && 
        p.alive
    );
}

// 獲取從玩家開始的同伴鏈
function getCompanionChain(leader) {
    const chain = [];
    const added = new Set();
    
    // 首先添加玩家
    if (leader.alive) {
        chain.push(leader);
        added.add(leader);
    }
    
    // 然後按跟隨關係添加同伴
    let current = leader;
    while (true) {
        // 查找所有把current當作leader的同伴
        const nextCompanions = players.filter(p => 
            p.isCompanion && 
            p.companionOf === current && 
            p.alive &&
            !added.has(p)
        );
        
        if (nextCompanions.length === 0) break;
        
        // 通常只會有一個直接跟隨者，但為了安全考慮
        nextCompanions.forEach(companion => {
            chain.push(companion);
            added.add(companion);
            current = companion;
        });
    }
    
    return chain;
}


function findNearestEnemyForCompanion(companion) {
    let nearestEnemy = null;
    let minDistance = companion.companionAttackRange;
    
    // 檢查敵人
    enemies.forEach(enemy => {
        const dist = Math.sqrt((enemy.x - companion.x) ** 2 + (enemy.y - companion.y) ** 2);
        if (dist < minDistance && hasLineOfSight(companion.x, companion.y, enemy.x, enemy.y)) {
            minDistance = dist;
            nearestEnemy = enemy;
        }
    });
    
    return nearestEnemy;
}

function attackEnemy(companion, enemy) {
    // 減少攻擊冷卻時間
    if (companion.companionAttackCooldown > 0) {
        companion.companionAttackCooldown--;
        return;
    }
    
    // 計算攻擊方向（基於敵人當前位置）
    const dx = enemy.x - companion.x;
    const dy = enemy.y - companion.y;
    const angle = Math.atan2(dy, dx);
    
    // 創建子彈（使用同伴的當前位置）
    bullets.push({
        x: companion.x,
        y: companion.y,
        dx: Math.cos(angle) * 0.8,
        dy: Math.sin(angle) * 0.8,
        distanceTraveled: 0,
        range: 10,
        penetration: 1,
        enemiesHit: 0,
        firedBy: 'companion'
    });
    
    // 設置攻擊冷卻
    companion.companionAttackCooldown = 10; // 約0.5秒
}

function moveToTarget(companion) {
    if (!companion.companionTarget) return;

    // 更新位置記錄（每100ms檢查一次）
    const now = Date.now();
    if (now - companion.positionUpdateTime > 100) {
        const movedDistance = distance(
            companion.x, companion.y,
            companion.lastPosition.x, companion.lastPosition.y
        );
        
        // 如果移動距離很小，增加計時器
        if (movedDistance < 0.1) {
            companion.collisionTimer += (now - companion.positionUpdateTime);
        } else {
            companion.collisionTimer = 0;
            companion.collisionDisabled = false;
        }
        
        companion.lastPosition = { x: companion.x, y: companion.y };
        companion.positionUpdateTime = now;
        
        // 如果卡住超過3秒，禁用碰撞
        if (companion.collisionTimer > 3000 && !companion.collisionDisabled) {
            companion.collisionDisabled = true;
            showStatusMessage('同伴卡住，暫時允許穿透!', 'warning');
        }
    }

    const dx = companion.companionTarget.x - companion.x;
    const dy = companion.companionTarget.y - companion.y;
    const distanceToTarget = Math.sqrt(dx * dx + dy * dy);

    if (distanceToTarget < 0.5) {
        companion.companionTarget = null;
        companion.collisionDisabled = false;
        companion.collisionTimer = 0;
        return;
    }

    const speed = (companion.companionSpeed / cellSize) * 0.5;
    const moveX = (dx / distanceToTarget) * speed;
    const moveY = (dy / distanceToTarget) * speed;

    // 根據碰撞狀態決定是否檢測碰撞
    if (companion.collisionDisabled) {
        // 碰撞禁用時直接移動
        companion.x += moveX;
        companion.y += moveY;
        
        // 如果移動距離足夠大，重新啟用碰撞
        if (distanceToTarget > 1.0) {
            companion.collisionDisabled = false;
            companion.collisionTimer = 0;
        }
    } else {
        // 正常碰撞檢測
        let canMoveX = true;
        let canMoveY = true;
        
        players.forEach(other => {
            if (other !== companion && other.alive && !other.collisionDisabled) {
                const distX = Math.abs((companion.x + moveX) - other.x);
                const distY = Math.abs((companion.y + moveY) - other.y);
                
                if (distX < 0.5 && distY < 0.5) {
                    if (distX < distY) {
                        canMoveX = false;
                    } else {
                        canMoveY = false;
                    }
                }
            }
        });
        
        if (canMoveX && !isColliding(companion.x + moveX, companion.y)) {
            companion.x += moveX;
        }
        if (canMoveY && !isColliding(companion.x, companion.y + moveY)) {
            companion.y += moveY;
        }
    }
}


function createCompanion(basePlayer) {
    return {
        ...basePlayer,
        isCompanion: true,
        companionOf: currentPlayerIndex,
        companionState: 'idle',
        companionSpeed: 1.5,
        companionAttackRange: 8,
        companionAttackCooldown: 0,
        companionFollowingDistance: 1.5,
        collisionDisabled: false,      // 新增：是否禁用碰撞
        collisionTimer: 0,             // 新增：碰撞計時器
        lastPosition: { x: 0, y: 0 },  // 新增：記錄最後位置
        positionUpdateTime: Date.now() // 新增：位置更新時間
    };
}
function followLeader(companion, leader) {
    updatePositionHistory(companion);
    handleStuckDetection(companion);
    
    const distanceToLeader = calculateDistance(companion, leader);
    
    if (isWithinFollowingDistance(distanceToLeader, companion)) {
        resetCollisionStatus(companion);
        return;
    }
    
    const { moveX, moveY } = calculateMovementVector(companion, leader, distanceToLeader);
    
    if (companion.collisionDisabled) {
        moveWithoutCollision(companion, moveX, moveY, distanceToLeader);
        return;
    }
    
    moveWithCollisionDetection(companion, leader, moveX, moveY);
}

// 更新位置歷史記錄
function updatePositionHistory(companion) {
    const now = Date.now();
    if (now - companion.positionUpdateTime > 100) {
        const movedDistance = calculateMovedDistance(companion);
        
        updateCollisionTimer(companion, movedDistance, now);
        
        companion.lastPosition = { x: companion.x, y: companion.y };
        companion.positionUpdateTime = now;
    }
}

// 計算移動距離
function calculateMovedDistance(companion) {
    return Math.sqrt(
        Math.pow(companion.x - companion.lastPosition.x, 2) +
        Math.pow(companion.y - companion.lastPosition.y, 2)
    );
}

// 更新碰撞計時器
function updateCollisionTimer(companion, movedDistance, currentTime) {
    if (movedDistance < 0.1) {
        companion.collisionTimer += (currentTime - companion.positionUpdateTime);
    } else {
        companion.collisionTimer = 0;
        companion.collisionDisabled = false;
    }
}

// 處理卡住檢測
function handleStuckDetection(companion) {
    if (companion.collisionTimer > 3000 && !companion.collisionDisabled) {
        companion.collisionDisabled = true;
        showStatusMessage(`同伴${players.indexOf(companion)+1}卡住，暫時允許穿透!`, 'warning');
    }
}

// 計算距離
function calculateDistance(companion, leader) {
    const dx = leader.x - companion.x;
    const dy = leader.y - companion.y;
    return Math.sqrt(dx * dx + dy * dy);
}

// 檢查是否在跟隨距離內
function isWithinFollowingDistance(distance, companion) {
    return distance <= companion.companionFollowingDistance;
}

// 重置碰撞狀態
function resetCollisionStatus(companion) {
    if (companion.collisionDisabled) {
        companion.collisionDisabled = false;
        companion.collisionTimer = 0;
    }
}

// 計算移動向量
function calculateMovementVector(companion, leader, distance) {
    const speed = companion.companionSpeed / cellSize;
    const dx = leader.x - companion.x;
    const dy = leader.y - companion.y;
    
    return {
        moveX: (dx / distance) * speed,
        moveY: (dy / distance) * speed
    };
}

// 無碰撞移動
function moveWithoutCollision(companion, moveX, moveY, distanceToLeader) {
    companion.x += moveX;
    companion.y += moveY;
    
    if (distanceToLeader < companion.companionFollowingDistance * 2) {
        companion.collisionDisabled = false;
        companion.collisionTimer = 0;
        showStatusMessage(`同伴${players.indexOf(companion)+1}已恢復正常碰撞!`, 'success');
    }
}

// 有碰撞檢測的移動
function moveWithCollisionDetection(companion, leader, moveX, moveY) {
    const { canMoveX, canMoveY } = checkCollisions(companion, leader, moveX, moveY);
    
    if (canMoveX && !isColliding(companion.x + moveX, companion.y)) {
        companion.x += moveX;
    }
    if (canMoveY && !isColliding(companion.x, companion.y + moveY)) {
        companion.y += moveY;
    }
}

// 檢查碰撞
function checkCollisions(companion, leader, moveX, moveY) {
    let canMoveX = true;
    let canMoveY = true;
    
    players.forEach(other => {
        if (other !== companion && other.alive && (other.isCompanion || other === leader)) {
            const distX = Math.abs((companion.x + moveX) - other.x);
            const distY = Math.abs((companion.y + moveY) - other.y);
            
            if (distX < 1 && distY < 1) {
                if (distX < distY) {
                    canMoveX = false;
                } else {
                    canMoveY = false;
                }
            }
        }
    });
    
    return { canMoveX, canMoveY };
}




// 放置傳送點時確保配對正確
function placeTeleport(x, y) {
    // 檢查是否已有傳送點在該位置
    const existingTeleport = teleports.find(tp => 
        Math.floor(tp.x) === x && 
        Math.floor(tp.y) === y
    );
    
    if (existingTeleport) {
        showStatusMessage(`此位置已有傳送點 (組 ${existingTeleport.pairId+1}${existingTeleport.isA ? 'A' : 'B'})`, 'error');
        return false;
    }

    // 創建新傳送點
    const newTeleport = {
        x: x + 0.5, // 放在格子中心
        y: y + 0.5,
        color: currentTeleportColor,
        pairId: currentTeleportPairId,
        isA: placingTeleportA
    };

    // 添加到傳送點列表
    teleports.push(newTeleport);

    // 更新配對關係
    if (!teleportPairs[currentTeleportPairId]) {
        teleportPairs[currentTeleportPairId] = {
            color: currentTeleportColor,
            points: [newTeleport]
        };
        showStatusMessage(`已放置第 ${currentTeleportPairId+1} 組傳送點 A (位置: ${x},${y})`, 'success');
        placingTeleportA = false;
    } else {
        teleportPairs[currentTeleportPairId].points.push(newTeleport);
        showStatusMessage(`已放置第 ${currentTeleportPairId+1} 組傳送點 B (位置: ${x},${y})`, 'success');
        
        // 完成一對後，準備下一組
        currentTeleportColor = getRandomFluorescentColor();
        currentTeleportPairId++;
        placingTeleportA = true;
    }

    // 更新UI顯示
    updateTeleportGroupDisplay();
    
    return true;
}

function updateTeleportGroupDisplay() {
    const groupDisplay = document.getElementById('teleportGroupDisplay');
    if (groupDisplay) {
        groupDisplay.innerHTML = `
            當前組別: <span id="currentGroup">${currentTeleportPairId + 1}</span>, 
            顏色: <span id="currentColor" style="color:${currentTeleportColor}">■</span>
            ${placingTeleportA ? '(放置A點)' : '(放置B點)'}
        `;
    }
}


function drawTeleports() {
    teleports.forEach(tp => {
        const alpha = gameState === 'playing' ? 0.9 : 0.6;
        const screenX = (tp.x - cameraOffset.x) * cellSize;
        const screenY = (tp.y - cameraOffset.y) * cellSize;
        
        // 繪製傳送點外圈
        ctx.fillStyle = tp.color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(screenX, screenY, cellSize * 0.45, 0, Math.PI * 2);
        ctx.fill();
        
        // 繪製內圈增加立體感
        ctx.fillStyle = lightenColor(tp.color, 20);
        ctx.beginPath();
        ctx.arc(screenX, screenY, cellSize * 0.35, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1.0;

        // 繪製組別和A/B標記
        ctx.fillStyle = '#000';
        ctx.font = `bold ${cellSize * 0.4}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
            `${tp.pairId+1}${tp.isA ? 'A' : 'B'}`,
            screenX,
            screenY
        );

        // 遊戲模式下添加脈動效果
        if (gameState === 'playing') {
            const pulse = 0.1 * Math.sin(Date.now() / 300);
            ctx.strokeStyle = lightenColor(tp.color, 30);
            ctx.lineWidth = 1 + pulse;
            ctx.beginPath();
            ctx.arc(screenX, screenY, cellSize * 0.55, 0, Math.PI * 2);
            ctx.stroke();
        }
    });
}


function createWindow(x, y) {
    return {
        x: x,
        y: y,
        health: 100,       // 窗戶耐久度
        lastHitTime: 0,    // 最後被撞擊時間
        bulletHits: 0      // 被子彈擊中次數
    };
}

// 獲取隨機螢光顏色// 獲取隨機螢光色
function getRandomFluorescentColor() {
    const colors = ['#FF00FF', '#00FFFF', '#FFFF00', '#FF00FF', '#00FF00', '#FF6600'];
    return colors[Math.floor(Math.random() * colors.length)];
}


// 新增函數：檢查點是否在玩家視覺範圍內
// 檢查點是否在玩家視覺範圍內
function isInPlayerVision(player, targetX, targetY) {
    // 計算目標與玩家的距離
    const dx = targetX - player.x;
    const dy = targetY - player.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 如果目標在1/3半徑範圍內，直接返回true
    const innerRadius = visionRange / 3;
    if (distance <= innerRadius) return true;
    
    // 如果超出視覺範圍半徑，直接返回false
    if (distance > visionRange) return false;
    
    // 計算目標相對於玩家的角度
    let angleToTarget = Math.atan2(dy, dx);
    
    // 調整角度使其與玩家角度在同一範圍內
    while (angleToTarget - player.angle > Math.PI) angleToTarget -= Math.PI * 2;
    while (angleToTarget - player.angle < -Math.PI) angleToTarget += Math.PI * 2;
    
    // 檢查是否在視角範圍內
    if (Math.abs(angleToTarget - player.angle) > visionAngleRadians) return false;
    
    // 檢查是否有牆壁阻擋視線
    return hasLineOfSight(player.x, player.y, targetX, targetY);
}


function reloadWeapon(player) {
    // 检查是否已经在装弹或弹匣已满
    const weaponType = player.weaponMode === 1 ? 'pistol' : 
                      player.weaponMode === 2 ? 'auto' : 'shotgun';
    
    if (player.isReloading || player.ammo >= player.magazineSize[weaponType]) {
        return;
    }

    if (player.totalAmmo <= 0) {
        showStatusMessage('無備用彈藥！', 'error');
        return;
    }

    // 开始装弹
    player.isReloading = true;
    player.reloadStartTime = performance.now(); // 使用performance.now()更精确
    player.canMove = false;
    player.canShoot = false;
    
    // 显示装弹信息
    const reloadTime = player.reloadTime[weaponType];
    showStatusMessage(`正在上彈... (${reloadTime}秒)`, 'info');
    console.log(`开始装弹，武器类型: ${weaponType}，装弹时间: ${reloadTime}秒`);
}

        function initGrid() {
            try {
                grid = [];
                for (let i = 0; i < gridSize; i++) {
                    grid[i] = Array(gridSize).fill('empty');
                }
                if (!savedGrid) {
                    savedGrid = grid.map(row => [...row]);
                    savedEnemies = [];
                    savedDefenseAreas = [];
                    players = [];
                    currentPlayerIndex = 0;
                } else {
                    grid = savedGrid.map(row => [...row]);
                    enemies = JSON.parse(JSON.stringify(savedEnemies));
                    defenseAreas = JSON.parse(JSON.stringify(savedDefenseAreas));
                }
                bullets = [];
                enemyBullets = [];
                grenade = null;
                mouseDown = false;
                lastMousePos = { clientX: 0, clientY: 0 };
            } catch (error) {
                console.error('網格初始化錯誤:', error);
            }
        }

function resizeCanvas() {
    if (isEditMode) {
        // 編輯模式：畫布大小 = 網格實際大小
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;
    } else {
        // 遊戲模式：固定視窗大小
        canvas.width = viewportWidth * cellSize;
        canvas.height = viewportHeight * cellSize;
    }
    // 重绘网格
    drawGrid();
}


function updatePlayersDisplay() {
    playersStats.innerHTML = '';
    players.forEach((player, index) => {
        if (player && typeof player.alive !== 'undefined') { // 確保是有效玩家對象
            const playerElement = document.createElement('div');
            playerElement.className = `player-stat ${index === currentPlayerIndex ? 'active' : ''} ${!player.alive ? 'dead' : ''}`;
            playerElement.innerHTML = `
                <div class="player-name">玩家 ${index + 1}</div>
                <div class="player-health">${player.alive ? '生命: ' + player.health : '已死亡'}</div>
            `;
            playersStats.appendChild(playerElement);
        }
    });
}

        function getLineCells(x0, y0, x1, y1) {
            const cells = [];
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                cells.push({ x: x0, y: y0 });
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
            return cells;
        }

// Modified getCurveCells function to generate quadratic Bézier curve cells
function getCurveCells(x0, y0, cx, cy, x1, y1) {
    const cells = new Set();
    const steps = 100; // Number of points to approximate the curve
    
    for (let t = 0; t <= 1; t += 1 / steps) {
        // Quadratic Bézier curve formula: B(t) = (1-t)^2*P0 + 2*(1-t)*t*P1 + t^2*P2
        const u = 1 - t;
        const uu = u * u;
        const tt = t * t;
        const ut2 = 2 * u * t;
        
        const x = uu * x0 + ut2 * cx + tt * x1;
        const y = uu * y0 + ut2 * cy + tt * y1;
        
        const gridX = Math.floor(x);
        const gridY = Math.floor(y);
        
        if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            cells.add(`${gridX},${gridY}`);
        }
    }
    
    return Array.from(cells).map(coord => {
        const [x, y] = coord.split(',').map(Number);
        return { x, y };
    });
}

// Modified drawGrid function to enhance grenade visualization
// Modified drawGrid function to visualize curve wall during drawing
// Clear the canvas
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// Draw grid lines in setup mode
function drawGridLines() {
    if (gameState === 'setup') {
        // 繪製網格線（僅在設置模式）
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 0.5;
        
        // 水平線
        for (let i = 0; i <= gridSize; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * cellSize);
            ctx.lineTo(gridSize * cellSize, i * cellSize);
            ctx.stroke();
        }
        
        // 垂直線
        for (let i = 0; i <= gridSize; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, gridSize * cellSize);
            ctx.stroke();
        }
    }

    // 繪製所有傳送點
    teleports.forEach(tp => {
        const screenX = (tp.x + 0.5) * cellSize;
        const screenY = (tp.y + 0.5) * cellSize;
        const radius = cellSize * 0.45;
        
        // 設置透明度（遊戲模式更鮮豔）
        const alpha = gameState === 'playing' ? 0.9 : 0.6;
        ctx.globalAlpha = alpha;
        
        // 繪製外圈
        ctx.fillStyle = tp.color;
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // 繪製內圈（立體效果）
        ctx.fillStyle = lightenColor(tp.color, 20);
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius * 0.78, 0, Math.PI * 2);
        ctx.fill();
        
        // 重置透明度
        ctx.globalAlpha = 1.0;
        
        // 繪製組別標記
        ctx.fillStyle = '#000';
        ctx.font = `bold ${cellSize * 0.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 顯示組別和AB標記 (例如: "3A" 表示第3組的A點)
        const groupNumber = tp.pairId + 1;
        ctx.fillText(`${groupNumber}${tp.isA ? 'A' : 'B'}`, screenX, screenY);
        
        // 遊戲模式下添加脈動效果
        if (gameState === 'playing') {
            const pulse = 0.1 * Math.sin(Date.now() / 300);
            ctx.strokeStyle = lightenColor(tp.color, 30);
            ctx.lineWidth = 1 + pulse;
            ctx.beginPath();
            ctx.arc(screenX, screenY, radius * 1.2, 0, Math.PI * 2);
            ctx.stroke();
        }
    });
}

// 輔助函數：顏色增亮
function lightenColor(color, percent) {
    // 將十六進制顏色轉換為RGB
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    
    // 轉換回十六進制
    return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
}


// Draw walls and doors
function drawGridItems() {


    // 繪製傳送點（移動到這裡）
    teleports.forEach(tp => {
        const alpha = gameState === 'playing' ? 0.9 : 0.6;
        ctx.fillStyle = tp.color;
        ctx.globalAlpha = alpha;
        
        // 繪製傳送點外圈
        ctx.beginPath();
        ctx.arc(
            (tp.x + 0.5) * cellSize, 
            (tp.y + 0.5) * cellSize, 
            cellSize * 0.45, 0, Math.PI * 2
        );
        ctx.fill();
        
        // 繪製內圈增加立體感
        ctx.fillStyle = lightenColor(tp.color, 20);
        ctx.beginPath();
        ctx.arc(
            (tp.x + 0.5) * cellSize, 
            (tp.y + 0.5) * cellSize, 
            cellSize * 0.35, 0, Math.PI * 2
        );
        ctx.fill();
        
        ctx.globalAlpha = 1.0;

        // 繪製A/B標記
        ctx.fillStyle = '#000';
        ctx.font = 'bold ' + (cellSize * 0.5) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
            tp.isA ? 'A' : 'B', 
            (tp.x + 0.5) * cellSize, 
            (tp.y + 0.5) * cellSize
        );
    });

    // 繪製窗戶
    windows.forEach(win => {
        const alpha = win.health / 100 * 0.7; // 根據耐久度調整透明度
        ctx.fillStyle = `rgba(0, 150, 255, ${alpha})`;
        ctx.fillRect(win.x * cellSize, win.y * cellSize, cellSize, cellSize);
        
        // 被撞擊或射擊效果
        if (Date.now() - win.lastHitTime < 300) { // 300毫秒內顯示效果
            ctx.strokeStyle = `rgba(255, 50, 50, ${0.5 + (1 - win.health/100)})`;
            ctx.lineWidth = 1 + (1 - win.health/100) * 3;
            
            // 繪製裂痕效果
            for (let i = 0; i < 3 + win.bulletHits; i++) {
                ctx.beginPath();
                ctx.moveTo(
                    win.x * cellSize + Math.random() * cellSize,
                    win.y * cellSize + Math.random() * cellSize
                );
                ctx.lineTo(
                    win.x * cellSize + Math.random() * cellSize,
                    win.y * cellSize + Math.random() * cellSize
                );
                ctx.stroke();
            }
        }
    });

        // 繪製彈藥庫
    drawAmmoDepots();
    for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
            if (grid[i][j] === 'wall') {
                ctx.fillStyle = '#666';
                ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else if (grid[i][j] === 'door') {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
        }
    }
}

// Draw defense areas and preview
function drawDefenseAreas() {
    if (gameState === 'setup') {
        defenseAreas.forEach(area => {
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.fillRect(area.x * cellSize, area.y * cellSize, area.width * cellSize, area.height * cellSize);
        });

        if (currentDefenseArea) {
            const rect = getRectCoords(currentDefenseArea);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.fillRect(rect.x * cellSize, rect.y * cellSize, rect.width * cellSize, rect.height * cellSize);
        }
    }
}

// Draw enemy paths and points
function drawEnemyPaths() {
    if (gameState === 'setup' && settingEnemyPath) {
        enemies.forEach(enemy => {
            if (enemy.path && enemy.path.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = enemy === currentPathEnemy ? '#FF00FF' : 'rgba(255,0,255,0.3)';
                ctx.lineWidth = enemy === currentPathEnemy ? 3 : 1;
                ctx.moveTo(enemy.path[0].x * cellSize + cellSize / 2, enemy.path[0].y * cellSize + cellSize / 2);
                for (let i = 1; i < enemy.path.length; i++) {
                    ctx.lineTo(enemy.path[i].x * cellSize + cellSize / 2, enemy.path[i].y * cellSize + cellSize / 2);
                }
                ctx.stroke();

                enemy.path.forEach((point, index) => {
                    ctx.fillStyle = index === 0 ? '#00ff00' : (index === enemy.path.length - 1 ? '#ff0000' : '#ffff00');
                    ctx.beginPath();
                    ctx.arc(point.x * cellSize + cellSize / 2, point.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                if (enemy.isBeingEdited) {
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(enemy.x * cellSize, enemy.y * cellSize - 15, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        });

        if (enemyPathPoints.length > 0) {
            enemyPathPoints.forEach((point, index) => {
                ctx.fillStyle = index === 0 ? '#00ff00' : (index === enemyPathPoints.length - 1 ? '#ff0000' : '#ffff00');
                ctx.beginPath();
                ctx.arc(point.x * cellSize + cellSize / 2, point.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            if (enemyPathPoints.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = enemy === currentPathEnemy ? '#FF00FF' : 'rgba(255,0,255,0.3)';
                ctx.lineWidth = enemy === currentPathEnemy ? 3 : 1;
                ctx.moveTo(enemyPathPoints[0].x * cellSize + cellSize / 2, enemyPathPoints[0].y * cellSize + cellSize / 2);
                for (let i = 1; i < enemyPathPoints.length; i++) {
                    ctx.lineTo(enemyPathPoints[i].x * cellSize + cellSize / 2, enemyPathPoints[i].y * cellSize + cellSize / 2);
                }
                ctx.stroke();
            }
        }
    }
}

// Draw players and health indicators
function drawPlayers() {
    const currentPlayer = players[currentPlayerIndex];
    
    // 只在遊戲模式計算攝像機偏移
    if (!isEditMode && currentPlayer && currentPlayer.alive) {
        cameraOffset.x = currentPlayer.x - viewportWidth / 2;
        cameraOffset.y = currentPlayer.y - viewportHeight / 2;
    }

    players.forEach((player, index) => {
        if (!player.alive) return;

        // 在遊戲模式中，跳過當前玩家的原始位置繪製
        if (!isEditMode && index === currentPlayerIndex) return;

        let screenX, screenY;
        
        if (isEditMode) {
            // 編輯模式：直接使用網格坐標
            screenX = player.x * cellSize;
            screenY = player.y * cellSize;
        } else {
            // 遊戲模式：只繪製同伴
            if (!player.isCompanion) return;
            
            // 考慮攝像機偏移
            screenX = (player.x - cameraOffset.x) * cellSize;
            screenY = (player.y - cameraOffset.y) * cellSize;
        }

        // 確保坐標在合理範圍內
        if (screenX < -cellSize || screenX > canvas.width + cellSize ||
            screenY < -cellSize || screenY > canvas.height + cellSize) {
            return;
        }

        // 繪製玩家（同伴或其他玩家）
        ctx.save();
        ctx.translate(screenX, screenY);
        
        // 設置玩家顏色
        ctx.fillStyle = player.isCompanion ? '#9b59b6' : '#5dade2';
        
        // 繪製玩家身體
        ctx.beginPath();
        ctx.arc(0, 0, cellSize / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // 繪製武器方向
        ctx.strokeStyle = '#ecf0f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(
            Math.cos(player.angle) * cellSize / 2, 
            Math.sin(player.angle) * cellSize / 2
        );
        ctx.stroke();
        
        ctx.restore();
        
        // 繪製同伴狀態標記
        if (player.isCompanion) {
            ctx.fillStyle = '#f1c40f';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('同伴', screenX, screenY - 20);
            
            // 繪製目標標記
            if (player.companionTarget) {
                let targetX, targetY;
                
                if (isEditMode) {
                    targetX = player.companionTarget.x * cellSize;
                    targetY = player.companionTarget.y * cellSize;
                } else {
                    targetX = (player.companionTarget.x - cameraOffset.x) * cellSize;
                    targetY = (player.companionTarget.y - cameraOffset.y) * cellSize;
                }
                
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(241, 196, 15, 0.3)';
                ctx.beginPath();
                ctx.arc(targetX, targetY, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 繪製生命值條
        if (player.health < 100) {
            drawHealthBar(player, screenX, screenY);
        }
    });

    // 單獨繪製當前玩家（在畫面中央）
    if (!isEditMode && currentPlayer && currentPlayer.alive) {
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        
        // 繪製當前玩家
        ctx.fillStyle = '#3498db';
        ctx.beginPath();
        ctx.arc(0, 0, cellSize / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // 繪製武器方向
        ctx.strokeStyle = '#ecf0f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(
            Math.cos(currentPlayer.angle) * cellSize / 2, 
            Math.sin(currentPlayer.angle) * cellSize / 2
        );
        ctx.stroke();
        
        ctx.restore();
        
        // 繪製生命值條
        if (currentPlayer.health < 100) {
            drawHealthBar(currentPlayer, canvas.width / 2, canvas.height / 2);
        }
    }
}


function drawSinglePlayer(player, screenX, screenY, index) {


    ctx.save();
    ctx.translate(screenX, screenY);
    
    // 設置玩家顏色
    if (player.isCompanion) {
        ctx.fillStyle = '#9b59b6'; // 同伴紫色
    } else if (index === currentPlayerIndex) {
        ctx.fillStyle = '#3498db'; // 當前玩家藍色
    } else {
        ctx.fillStyle = '#5dade2'; // 其他玩家淺藍色
    }
    
    // 繪製玩家圓形
    ctx.beginPath();
    ctx.arc(0, 0, cellSize / 2, 0, Math.PI * 2);
    ctx.fill();
    
    // 繪製武器方向
    ctx.strokeStyle = '#ecf0f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(
    Math.cos(player.angle) * cellSize / 2,
    Math.sin(player.angle) * cellSize / 2
);
    ctx.stroke();
    
    ctx.restore();
    
    // 只有當前玩家才顯示名稱和彈藥信息
    if (index === currentPlayerIndex) {
    // 繪製玩家標記（白色，半透明）
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // 70% 不透明
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`P${index+1}`, screenX, screenY - 25);

    // 繪製彈藥信息（橙色，半透明）
    const ammoText = `${player.ammo}|${player.totalAmmo}|${player.grenadeCount}`;
    ctx.fillStyle = 'rgba(241, 196, 15, 0.7)'; // 橙色 (#f1c40f)，70% 不透明
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(ammoText, screenX, screenY - 10);

    // 繪製體力圈（半透明綠/紅）
    const staminaX = screenX + 30;
    const staminaY = screenY - 10;
    
    const staminaAngle = (player.stamina / 100) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(staminaX, staminaY, 4, -Math.PI/2, -Math.PI/2 + staminaAngle);
    ctx.lineWidth = 4;
        // 根據不同狀態設置顏色
    if (player.isSprinting) {
        // 衝刺模式 - 紅色
        ctx.strokeStyle = 'rgba(231, 76, 60, 0.7)'; // 紅 (#e74c3c)
    } else if (player.isSlowWalking) {
        // 慢速模式 - 藍色
        ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)'; // 藍 (#3498db)
    } else if (player.stamina > 20) {
        // 正常模式 - 綠色
        ctx.strokeStyle = 'rgba(46, 204, 113, 0.7)'; // 綠 (#2ecc71)
    } else {
        // 體力不足 - 黃色
        ctx.strokeStyle = 'rgba(241, 196, 15, 0.7)'; // 黃 (#f1c40f)
    }
    ctx.stroke();
    // 綠圈（半透明）或紅圈（半透明）
    if (player.stamina > 20) {
        ctx.strokeStyle = 'rgba(46, 204, 113, 0.5)'; // 半透明綠 (#2ecc71)
    } else {
        ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';  // 半透明紅 (#e74c3c)
    }
    ctx.stroke();
}
    
    // 繪製生命值條（保持原位置）
    if (player.health < 100) {
        drawPlayerHealthBar(player, screenX, screenY);
    }
}

function drawLaserSight(player) {
    // 獲取當前武器射程
    let range;
    switch(player.weaponMode) {
        case 1: range = bulletSettings.pistol.range * cellSize; break;
        case 2: range = bulletSettings.auto.range * cellSize; break;
        case 3: range = bulletSettings.shotgun.range * cellSize; break;
    }

    // 計算方向向量（指向實際鼠標位置）
    const dx = mouseX - player.x * cellSize;
    const dy = mouseY - player.y * cellSize;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 射線終點（考慮牆壁碰撞）
    let endX = player.x * cellSize;
    let endY = player.y * cellSize;
    let hitWall = false;
    
    // 使用 Bresenham 算法檢測牆壁碰撞
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    const xStep = dx / steps;
    const yStep = dy / steps;
    
    for (let i = 0; i <= steps && !hitWall; i++) {
        const testX = player.x * cellSize + xStep * i;
        const testY = player.y * cellSize + yStep * i;
        
        // 檢查是否超出射程
        const currentDist = Math.sqrt(
            (testX - player.x * cellSize) ** 2 + 
            (testY - player.y * cellSize) ** 2
        );
        if (currentDist > range) break;
        
        // 檢查牆壁碰撞（使用網格座標）
        const gridX = Math.floor(testX / cellSize);
        const gridY = Math.floor(testY / cellSize);
        
        if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            if (grid[gridY][gridX] === 'wall') {
                hitWall = true;
                // 調整終點到牆壁前一點
                endX = testX - xStep;
                endY = testY - yStep;
                break;
            }
        }
        
        endX = testX;
        endY = testY;
    }
    
    // 繪製紅色瞄準線
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(player.x * cellSize, player.y * cellSize);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    // 在終點添加小圓點
    ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
    ctx.beginPath();
    ctx.arc(endX, endY, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // 如果碰到牆壁，在牆壁上繪製碰撞標記
    if (hitWall) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.beginPath();
        ctx.arc(endX, endY, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // 繪製射程指示圓弧（當鼠標超出射程時）
    if (distance > range) {
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.arc(
            player.x * cellSize, 
            player.y * cellSize, 
            range, 
            player.angle - Math.PI/8, 
            player.angle + Math.PI/8
        );
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

// 绘制弹药信息
function drawAmmoInfo(player) {
    // 简化为纯数字显示：弹匣/总弹药/手雷
    const ammoText = `${player.ammo}/${player.totalAmmo}/${player.grenadeCount}`;
    
    // 设置文字样式（保持V74风格）
    ctx.fillStyle = '#f1c40f'; // 黄色文字
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // 绘制位置（玩家头顶）
    const textX = player.x * cellSize;
    const textY = player.y * cellSize - 15; // 向上偏移15像素
    
    // 绘制文字（无背景框）
    ctx.fillText(ammoText, textX, textY);
    
    // 装弹进度条（保留V74效果）
    if (player.isReloading) {
        const progress = (performance.now() - player.reloadStartTime) / (player.reloadTime * 1000);
        if (progress < 1) {
            const barWidth = 40;
            const barHeight = 3;
            const barX = textX - barWidth/2;
            const barY = textY + 10;
            
            ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
            ctx.fillRect(barX, barY, barWidth * progress, barHeight);
            ctx.strokeStyle = '#3498db';
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }
}

// 绘制生命值条
function drawHealthBar(player) {
    const healthBarWidth = cellSize;
    const healthBarHeight = 4;
    const healthX = player.x * cellSize - healthBarWidth/2;
    const healthY = player.y * cellSize + cellSize/2 + 2;
    
    // 背景
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(healthX, healthY, healthBarWidth, healthBarHeight);
    
    // 当前生命值
    ctx.fillStyle = player.health > 50 ? '#2ecc71' : 
                  player.health > 25 ? '#f39c12' : '#e74c3c';
    ctx.fillRect(
        healthX, 
        healthY, 
        healthBarWidth * (player.health / 100), 
        healthBarHeight
    );
}
// Draw enemies and detection ranges
function drawEnemies() {
    enemies.forEach(enemy => {
        // 繪製調試信息（僅測試模式）
        if (testMode && enemy.path && enemy.path.length > 0) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.fillText(`Path: ${enemy.currentPathIndex || 0}/${enemy.path.length - 1}`, 
                        enemy.x * cellSize + 10, enemy.y * cellSize - 10);
            
            // 測試模式下顯示路徑點
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(enemy.x * cellSize, enemy.y * cellSize - cellSize, cellSize / 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // 根據敵人類型繪製
        if (enemy.type === ENEMY_TYPES.LICKER) {
            // 使用統一的 Licker 繪製函數（不再繪製額外圓形）
            drawLicker(enemy, enemy.x * cellSize, enemy.y * cellSize);
        } 
        else {
            // 其他敵人類型的繪製邏輯
            ctx.fillStyle = enemy.type === 'zombie' ? '#2ecc71' : '#e74c3c';
            ctx.beginPath();
            ctx.arc(
                enemy.x * cellSize, 
                enemy.y * cellSize, 
                cellSize / 2, 
                0, 
                Math.PI * 2
            );
            ctx.fill();

            // 繪製路徑點（非設置路徑模式時）
            if (enemy.path && enemy.path.length > 0 && !settingEnemyPath) {
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(enemy.x * cellSize, enemy.y * cellSize - cellSize, cellSize / 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

function drawLicker(enemy, screenX, screenY) {
    // 保存當前繪圖狀態
    ctx.save();
    
    // 移動到繪製位置（中心點）
    ctx.translate(screenX + cellSize/2, screenY + cellSize/2);
    
    // 設置 Licker 顏色（暗紅色）
    ctx.fillStyle = '#8B0000';
    ctx.strokeStyle = '#FF6347';
    ctx.lineWidth = 2;
    
    // 繪製三角形身體（尖端朝上）
    const size = cellSize * 0.8;
    ctx.beginPath();
    ctx.moveTo(0, -size/2);          // 頂點
    ctx.lineTo(-size/2, size/2);     // 左下
    ctx.lineTo(size/2, size/2);      // 右下
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // 恢復繪圖狀態
    ctx.restore();
    
    // 繪製舌頭（如果正在攻擊）
    if (enemy.tongue) {
        drawTongueAttack(enemy);
    }
    
    // 繪製調試信息（如果需要）
    
}


function drawTongueAttack(licker) {
    const tongue = licker.tongue;
    const startX = (licker.x - cameraOffset.x) * cellSize + cellSize/2;
    const startY = (licker.y - cameraOffset.y) * cellSize + cellSize/2;
    
    let endX, endY;
    if (tongue.pulling) {
        // 拉回階段：連接Licker和玩家
        endX = (tongue.target.x - cameraOffset.x) * cellSize + cellSize/2;
        endY = (tongue.target.y - cameraOffset.y) * cellSize + cellSize/2;
    } else {
        // 伸出階段：動畫效果
        endX = lerp(
            startX, 
            (tongue.target.x - cameraOffset.x) * cellSize + cellSize/2, 
            tongue.progress
        );
        endY = lerp(
            startY, 
            (tongue.target.y - cameraOffset.y) * cellSize + cellSize/2, 
            tongue.progress
        );
    }
    // 繪製舌頭線條
    ctx.strokeStyle = 'rgba(255, 105, 180, 0.8)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // 繪製舌頭尖端
    ctx.fillStyle = 'rgba(255, 20, 147, 0.8)';
    ctx.beginPath();
    ctx.arc(endX, endY, 5, 0, Math.PI * 2);
    ctx.fill();
}


// 修改後的 drawBullets 函數，考慮子彈射程和穿透數量
function drawBullets() {
    bullets.forEach(bullet => {
        // 計算子彈在屏幕上的位置（考慮攝像機偏移）
        const screenX = (bullet.x - cameraOffset.x) * cellSize;
        const screenY = (bullet.y - cameraOffset.y) * cellSize;
        
        // 只在可見範圍內繪製
        if (screenX >= -cellSize && screenX <= canvas.width + cellSize &&
            screenY >= -cellSize && screenY <= canvas.height + cellSize) {
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(screenX, screenY, cellSize / 4, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

// Draw enemy bullets
function drawEnemyBullets() {
    enemyBullets.forEach(enemyBullet => {
        ctx.fillStyle = '#e67e22';
        ctx.beginPath();
        ctx.arc(enemyBullet.x * cellSize, enemyBullet.y * cellSize, cellSize / 4, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Draw grenade or target
function drawGrenade() {
    if (grenade && gameState === 'playing') {
        ctx.fillStyle = '#27ae60';
        ctx.beginPath();
        if (grenade.thrown) {
            ctx.arc(grenade.x * cellSize, grenade.y * cellSize, cellSize / 2, 0, Math.PI * 2);
        } else {
            ctx.arc(grenade.targetX * cellSize, grenade.targetY * cellSize, cellSize / 2, 0, Math.PI * 2);
        }
        ctx.fill();
    }
}

// Draw rectangular wall preview
function drawRectWallPreview() {
    if (gameState === 'setup' && currentPlacement === 'rectWall' && rectStart) {
        const rect = getRectCoords();
        ctx.strokeStyle = '#888';
        ctx.strokeRect(rect.x * cellSize, rect.y * cellSize, rect.width * cellSize, rect.height * cellSize);
    }
}

// Draw removal rectangle preview
function drawRemovePreview() {
    if (gameState === 'setup' && currentPlacement === 'remove' && rectStart) {
        const rect = getRectCoords();
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.strokeRect(rect.x * cellSize, rect.y * cellSize, rect.width * cellSize, rect.height * cellSize);
    }
}

// Draw line wall preview
function drawLineWallPreview() {
    if (gameState === 'setup' && currentPlacement === 'lineWall' && rectStart) {
        const cells = getLineCells(rectStart.x, rectStart.y, rectStart.currentX, rectStart.currentY);
        ctx.fillStyle = 'rgba(102, 102, 102, 0.5)';
        cells.forEach(cell => {
            ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
        });
    }
}

// Draw curve wall preview
function drawCurveWallPreview() {
    if (gameState === 'setup' && currentPlacement === 'curveWall' && rectStart) {
        if (curveDrawingState === 'drawing_line') {
            ctx.strokeStyle = 'rgba(102, 102, 102, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(rectStart.x * cellSize + cellSize / 2, rectStart.y * cellSize + cellSize / 2);
            ctx.lineTo(rectStart.currentX * cellSize + cellSize / 2, rectStart.currentY * cellSize + cellSize / 2);
            ctx.stroke();
        } else if (curveDrawingState === 'adjusting_curve' && curveControlPoint) {
            const cells = getCurveCells(rectStart.x, rectStart.y, curveControlPoint.x, curveControlPoint.y, rectStart.currentX, rectStart.currentY);
            ctx.fillStyle = 'rgba(102, 102, 102, 0.5)';
            cells.forEach(cell => {
                ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
            });
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(curveControlPoint.x * cellSize + cellSize / 2, curveControlPoint.y * cellSize + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

function drawRemoveEntityPreview() {
    if (gameState === 'setup' && currentPlacement === 'removeEntity' && rectStart) {
        const rect = getRectCoords();
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.strokeRect(rect.x * cellSize, rect.y * cellSize, rect.width * cellSize, rect.height * cellSize);
    }
}


// Modified drawGrid function to include background image
function drawGrid() {
    try {
        clearCanvas();
        
        if (isEditMode) {
            // 編輯模式：繪製完整地圖
            drawBackgroundImage();
            drawGridLines();
            drawGridItems();
            
            drawAllWindows();
            drawAmmoDepots(); // 添加這行

            drawAllTeleports();
            drawDefenseAreas();
            drawEnemyPaths();
            drawPlayers();
            drawEnemies();
            drawBullets();
            drawEnemyBullets();
            drawGrenade();
            drawRectWallPreview();
            drawRemovePreview();
            drawLineWallPreview();
            drawCurveWallPreview();
            drawRemoveEntityPreview();
        } else {
            // 遊戲模式：只繪製視窗範圍內的內容
            if (players.length > 0 && players[currentPlayerIndex].alive) {
                const player = players[currentPlayerIndex];
                
                // 計算攝像機偏移
                cameraOffset.x = player.x - viewportWidth/2;
                cameraOffset.y = player.y - viewportHeight/2;
                
                // 確保攝像機不會超出地圖邊界
                cameraOffset.x = Math.max(0, Math.min(cameraOffset.x, gridSize - viewportWidth));
                cameraOffset.y = Math.max(0, Math.min(cameraOffset.y, gridSize - viewportHeight));
                
                // 計算可見範圍
                const minX = Math.max(0, Math.floor(cameraOffset.x));
                const maxX = Math.min(gridSize, Math.floor(cameraOffset.x + viewportWidth));
                const minY = Math.max(0, Math.floor(cameraOffset.y));
                const maxY = Math.min(gridSize, Math.floor(cameraOffset.y + viewportHeight));
                
                // 繪製可見範圍內的內容
                drawVisibleArea(minX, maxX, minY, maxY);
                drawAmmoDepotsInView(minX, maxX, minY, maxY); // 確保這行存在
            }
        }
    } catch (error) {
        console.error('繪製網格錯誤:', error);
    }
}
function drawAmmoDepotsInView(minX, maxX, minY, maxY) {
    ammoDepots.forEach(depot => {
        if (depot.collected) return;
        
        const depotX = Math.floor(depot.x);
        const depotY = Math.floor(depot.y);
        
        if (depotX >= minX && depotX < maxX && depotY >= minY && depotY < maxY) {
            drawAmmoDepot(depot);
        }
    });
}


function drawWindow(win) {
    const alpha = gameState === 'playing' ? win.health / 100 * 0.7 : 0.7;
    ctx.fillStyle = `rgba(0, 150, 255, ${alpha})`;
    ctx.fillRect(win.x * cellSize, win.y * cellSize, cellSize, cellSize);
    
    // 编辑模式下显示窗户边框
    if (gameState === 'setup') {
        ctx.strokeStyle = '#00f';
        ctx.lineWidth = 1;
        ctx.strokeRect(win.x * cellSize, win.y * cellSize, cellSize, cellSize);
    }
}

function drawAllWindows() {
    windows.forEach(win => drawWindow(win));
}

function drawTeleport(tp) {
    ctx.fillStyle = tp.color;
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(
        (tp.x + 0.5) * cellSize, 
        (tp.y + 0.5) * cellSize, 
        cellSize * 0.4, 0, Math.PI * 2
    );
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // 顯示傳送組ID
    ctx.fillStyle = '#000';
    ctx.font = 'bold ' + (cellSize * 0.3) + 'px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(
        tp.pairId.toString().slice(-3), // 顯示簡短ID
        (tp.x + 0.5) * cellSize, 
        (tp.y + 0.5) * cellSize
    );
}

function drawAllTeleports() {
    teleports.forEach(tp => drawTeleport(tp));
}
function drawVisibleArea(minX, maxX, minY, maxY) {
    // 繪製網格背景
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 繪製玩家視覺範圍
    if (gameState === 'playing' && players.length > 0 && players[currentPlayerIndex].alive) {
        drawPlayerVision(players[currentPlayerIndex]);
    }

    // 根據遊戲狀態選擇繪製方式
    if (gameState === 'setup') {
        drawGridAndTerrain(minX, maxX, minY, maxY);
    } else {
        drawTerrainOnly(minX, maxX, minY, maxY);
    }

    // 繪製傳送點
    drawTeleportsInView(minX, maxX, minY, maxY);
    
    // 繪製窗戶（在遊戲模式和編輯模式都繪製）
    drawWindowsInView(minX, maxX, minY, maxY);

    // 繪製所有存活玩家（不僅是當前玩家）
    drawPlayersInView(minX, maxX, minY, maxY);

    // 繪製其他遊戲元素（防禦區域、敵人等）
    drawDefenseAreasInView(minX, maxX, minY, maxY);
    drawEnemiesInView(minX, maxX, minY, maxY);
    drawBulletsInView(minX, maxX, minY, maxY);
    drawEnemyBulletsInView(minX, maxX, minY, maxY);
    
    if (grenade) {
        drawGrenadeInView(minX, maxX, minY, maxY);
    }
    
    // 繪製紅外瞄準線（如果適用）
    if (gameState === 'playing' && players.length > 0 && players[currentPlayerIndex].alive) {
        drawLaserSightInView(players[currentPlayerIndex]);
    }
}

function drawTeleportsInView(minX, maxX, minY, maxY) {
    teleports.forEach(tp => {
        if (tp.x >= minX && tp.x < maxX && tp.y >= minY && tp.y < maxY) {
            const screenX = (tp.x - cameraOffset.x) * cellSize;
            const screenY = (tp.y - cameraOffset.y) * cellSize;
            
            // 繪製傳送點外圈
            ctx.fillStyle = tp.color;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(
                screenX + cellSize/2, 
                screenY + cellSize/2, 
                cellSize * 0.45, 0, Math.PI * 2
            );
            ctx.fill();
            
            // 繪製內圈
            ctx.fillStyle = lightenColor(tp.color, 20);
            ctx.beginPath();
            ctx.arc(
                screenX + cellSize/2, 
                screenY + cellSize/2, 
                cellSize * 0.35, 0, Math.PI * 2
            );
            ctx.fill();
            
            ctx.globalAlpha = 1.0;

            // 繪製A/B標記
            ctx.fillStyle = '#000';
            ctx.font = 'bold ' + (cellSize * 0.5) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                tp.isA ? 'A' : 'B', 
                screenX + cellSize/2, 
                screenY + cellSize/2
            );
        }
    });
}

function drawWindowsInView(minX, maxX, minY, maxY) {
    windows.forEach(win => {
        const winX = Math.floor(win.x);
        const winY = Math.floor(win.y);
        
        if (winX >= minX && winX < maxX && winY >= minY && winY < maxY) {
            const screenX = (winX - cameraOffset.x) * cellSize;
            const screenY = (winY - cameraOffset.y) * cellSize;
            
            ctx.fillStyle = 'rgba(0, 150, 255, 0.7)';
            ctx.fillRect(screenX, screenY, cellSize, cellSize);
            
            // 被撞擊效果
            if (Date.now() - win.lastHitTime < 1000) {
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(
                        screenX + Math.random() * cellSize,
                        screenY + Math.random() * cellSize
                    );
                    ctx.lineTo(
                        screenX + Math.random() * cellSize,
                        screenY + Math.random() * cellSize
                    );
                    ctx.stroke();
                }
            }
        }
    });
}

function drawPlayersInView(minX, maxX, minY, maxY) {
    players.forEach((player, index) => {
        if (player.alive) {
            const playerX = Math.floor(player.x);
            const playerY = Math.floor(player.y);
            
            if (playerX >= minX && playerX < maxX && 
                playerY >= minY && playerY < maxY) {
                const screenX = (player.x - cameraOffset.x) * cellSize;
                const screenY = (player.y - cameraOffset.y) * cellSize;
                drawSinglePlayer(player, screenX, screenY, index);
            }
        }
    });
}
function drawTerrainOnly(minX, maxX, minY, maxY) {
    for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
            const screenX = (x - cameraOffset.x) * cellSize;
            const screenY = (y - cameraOffset.y) * cellSize;
            
            // 只繪製牆壁和門
            if (y >= 0 && y < gridSize && x >= 0 && x < gridSize) {
                if (grid[y][x] === 'wall') {
                    ctx.fillStyle = '#666';
                    ctx.fillRect(screenX, screenY, cellSize, cellSize);
                } else if (grid[y][x] === 'door') {
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(screenX, screenY, cellSize, cellSize);
                }
            }
        }
    }
}

// 繪製網格背景
function drawGridBackground() {
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// 繪製網格線和地形
function drawGridAndTerrain(minX, maxX, minY, maxY) {
    for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
            const screenX = (x - cameraOffset.x) * cellSize;
            const screenY = (y - cameraOffset.y) * cellSize;
            
            // 繪製網格線（只在編輯模式）
            if (gameState === 'setup') {
                ctx.strokeStyle = '#555';
                ctx.strokeRect(screenX, screenY, cellSize, cellSize);
            }
            
            // 繪製牆壁和門（無論什麼模式都繪製）
            if (y >= 0 && y < gridSize && x >= 0 && x < gridSize) {
                if (grid[y][x] === 'wall') {
                    ctx.fillStyle = '#666';
                    ctx.fillRect(screenX, screenY, cellSize, cellSize);
                } else if (grid[y][x] === 'door') {
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(screenX, screenY, cellSize, cellSize);
                }
            }
        }
    }
}

// 繪製視窗內的防禦區域
function drawDefenseAreasInView(minX, maxX, minY, maxY) {
    defenseAreas.forEach(area => {
        const areaRight = area.x + area.width;
        const areaBottom = area.y + area.height;
        
        if (areaRight >= minX && area.x <= maxX && 
            areaBottom >= minY && area.y <= maxY) {
            
            const drawX = Math.max(area.x, minX);
            const drawY = Math.max(area.y, minY);
            const drawRight = Math.min(areaRight, maxX);
            const drawBottom = Math.min(areaBottom, maxY);
            
            const screenX = (drawX - cameraOffset.x) * cellSize;
            const screenY = (drawY - cameraOffset.y) * cellSize;
            const width = (drawRight - drawX) * cellSize;
            const height = (drawBottom - drawY) * cellSize;
            
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.fillRect(screenX, screenY, width, height);
        }
    });
}

// 繪製視窗內的玩家
function drawPlayerInView(player, screenX, screenY) {
    // 繪製玩家角色
    ctx.save();
    ctx.translate(screenX, screenY);
    
    // 設置玩家顏色
    if (player.isCompanion) {
        ctx.fillStyle = '#9b59b6'; // 同伴紫色
    } else {
        ctx.fillStyle = '#3498db'; // 玩家藍色
    }
    
    ctx.beginPath();
    ctx.arc(0, 0, cellSize / 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#ecf0f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(cellSize / 2, 0);
    ctx.stroke();
    
    ctx.restore();
    
    // 只有非同伴玩家才顯示彈藥信息
    if (!player.isCompanion) {
        // 繪製彈藥數字
        const ammoText = `${player.ammo}|${player.totalAmmo}|${player.grenadeCount}`;
        ctx.fillStyle = '#f1c40f';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(ammoText, screenX, screenY - 15);
    }
    
    // 繪製生命值條
    if (player.health < 100) {
        drawPlayerHealthBar(player, screenX, screenY);
    }
}

// 繪製玩家生命值條
function drawPlayerHealthBar(player, screenX, screenY) {
    const barWidth = cellSize;
    const barHeight = 4;
    const barX = screenX - barWidth / 2;
    const barY = screenY + cellSize / 2 + 2;
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    ctx.fillStyle = player.health > 50 ? '#2ecc71' : 
                  player.health > 25 ? '#f39c12' : '#e74c3c';
    ctx.fillRect(barX, barY, barWidth * (player.health / 100), barHeight);
}

// 繪製視窗內的敵人
// 修改後的 drawEnemiesInView 函數
// 修改drawEnemiesInView函數
function drawEnemiesInView(minX, maxX, minY, maxY) {
    if (shouldSkipDrawing()) return;
    
    const player = players[currentPlayerIndex];
    
    enemies.forEach(enemy => {
        const screenPos = calculateScreenPosition(enemy);
        
        if (isEnemyOnScreen(screenPos)) {
            if (shouldDrawEnemy(player, enemy)) {
                drawSingleEnemy(enemy, screenPos, player);
            }
        }
    });
}

// 小功能函數
function shouldSkipDrawing() {
    return players.length === 0 || !players[currentPlayerIndex].alive;
}

function calculateScreenPosition(enemy) {
    return {
        x: (enemy.x - cameraOffset.x) * cellSize,
        y: (enemy.y - cameraOffset.y) * cellSize
    };
}

function isEnemyOnScreen(screenPos) {
    return screenPos.x >= -cellSize * 3 && screenPos.x <= canvas.width + cellSize * 3 &&
           screenPos.y >= -cellSize * 3 && screenPos.y <= canvas.height + cellSize * 3;
}

function shouldDrawEnemy(player, enemy) {
    // 如果敵人在1/3半徑範圍內，總是可見
    const dx = enemy.x - player.x;
    const dy = enemy.y - player.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const innerRadius = visionRange / 3;
    
    if (distance <= innerRadius) return true;
    
    // 否則使用原有邏輯檢查扇形視野和視線
    return isInPlayerVision(player, enemy.x, enemy.y) || testMode;
}


function drawSingleEnemy(enemy, screenPos, player) {
    if (enemy.type === ENEMY_TYPES.LICKER) {
        drawLicker(enemy, screenPos.x, screenPos.y);
    } else {
        drawRegularEnemy(enemy, screenPos, player);
    }
}

function drawRegularEnemy(enemy, screenPos, player) {
    const isZombie = (enemy.type === 'zombie');
    const enemyColor = getEnemyColor(enemy, player, isZombie);
    
    // 繪製敵人身體
    ctx.fillStyle = enemyColor;
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y, cellSize / 2, 0, Math.PI * 2);
    ctx.fill();

    if (!isZombie) {
        drawEnemyVisionCone(enemy, screenPos);
        drawEnemyDirectionLine(enemy, screenPos);
    }
}

function getEnemyColor(enemy, player, isZombie) {
    if (!isZombie) return '#e74c3c';
    
    const isVisible = isInPlayerVision(player, enemy.x, enemy.y);
    const isActive = enemy.path?.length > 0 || 
                    (enemy.targetPlayer && hasLineOfSight(enemy.x, enemy.y, enemy.targetPlayer.x, enemy.targetPlayer.y, true));
    
    enemy.isActive = isActive; // 存儲活動狀態用於調試
    
    if (testMode) {
        let color = isActive ? '#2ecc71' : '#27ae60';
        if (!isVisible) color += '80'; // 50% 透明度
        return color;
    }
    
    return '#2ecc71';
}

function drawEnemyVisionCone(enemy, screenPos) {
    const alpha = testMode ? 0.15 : 0.3;
    ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, screenPos.y);
    ctx.arc(
        screenPos.x, screenPos.y,
        enemyVisionRange * cellSize,
        enemy.angle - enemyVisionAngle/2,
        enemy.angle + enemyVisionAngle/2
    );
    ctx.closePath();
    ctx.fill();
}

function drawEnemyDirectionLine(enemy, screenPos) {
    ctx.strokeStyle = '#ecf0f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, screenPos.y);
    ctx.lineTo(
        screenPos.x + Math.cos(enemy.angle) * cellSize / 2,
        screenPos.y + Math.sin(enemy.angle) * cellSize / 2
    );
    ctx.stroke();
}
// 新增函數：繪製玩家視覺範圍
function drawPlayerVision(player) {
    const centerX = (player.x - cameraOffset.x) * cellSize;
    const centerY = (player.y - cameraOffset.y) * cellSize;
    const radius = visionRange * cellSize;
    const innerRadius = (visionRange / 3) * cellSize;
    
    ctx.save();
    
    drawInnerGreenCircle(centerX, centerY, innerRadius);
    drawVisionCone(player, centerX, centerY, innerRadius, radius);
    drawFeatheredEdges(player, centerX, centerY, radius);
    
    ctx.restore();
}

function drawInnerGreenCircle(centerX, centerY, innerRadius) {
    ctx.globalAlpha = 0.1;
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
    ctx.fill();
}

function drawVisionCone(player, centerX, centerY, innerRadius, radius) {
    const gradient = createVisionConeGradient(ctx, centerX, centerY, innerRadius, radius);
    
    ctx.globalAlpha = 1;
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, 
            player.angle - visionAngleRadians, 
            player.angle + visionAngleRadians);
    ctx.closePath();
    ctx.fill();
}

function createVisionConeGradient(ctx, centerX, centerY, innerRadius, radius) {
    const gradient = ctx.createRadialGradient(
        centerX, centerY, innerRadius,
        centerX, centerY, radius
    );
    gradient.addColorStop(0, 'rgba(52, 156, 219, 0.15)');
    gradient.addColorStop(0.7, 'rgba(52, 156, 219, 0.08)');
    gradient.addColorStop(1, 'rgba(52, 156, 219, 0)');
    return gradient;
}

function drawFeatheredEdges(player, centerX, centerY, radius) {
    const featherWidth = radius * 0.25;
    const angleSteps = 15;
    const angleStep = (visionAngleRadians * 2) / angleSteps;
    
    for (let i = 0; i <= angleSteps; i++) {
        const angle = player.angle - visionAngleRadians + i * angleStep;
        drawFeatheredEdgeLine(ctx, centerX, centerY, radius, featherWidth, angle);
    }
}

function drawFeatheredEdgeLine(ctx, centerX, centerY, radius, featherWidth, angle) {
    const lineGradient = createEdgeGradient(ctx, centerX, centerY, radius, angle);
    
    ctx.strokeStyle = lineGradient;
    ctx.lineWidth = featherWidth * 0.8;
    ctx.beginPath();
    ctx.moveTo(
        centerX + Math.cos(angle) * (radius - featherWidth), 
        centerY + Math.sin(angle) * (radius - featherWidth)
    );
    ctx.lineTo(
        centerX + Math.cos(angle) * radius, 
        centerY + Math.sin(angle) * radius
    );
    ctx.stroke();
}

function createEdgeGradient(ctx, centerX, centerY, radius, angle) {
    const lineGradient = ctx.createLinearGradient(
        centerX, centerY,
        centerX + Math.cos(angle) * radius,
        centerY + Math.sin(angle) * radius
    );
    lineGradient.addColorStop(0, 'rgba(52, 156, 219, 0)');
    lineGradient.addColorStop(0.7, 'rgba(52, 156, 219, 0.03)');
    lineGradient.addColorStop(1, 'rgba(52, 156, 219, 0)');
    return lineGradient;
}


// 繪製視窗內的子彈
function drawBulletsInView(minX, maxX, minY, maxY) {
    bullets.forEach(bullet => {
        const screenX = (bullet.x - cameraOffset.x) * cellSize;
        const screenY = (bullet.y - cameraOffset.y) * cellSize;
        
        if (screenX >= -cellSize && screenX <= canvas.width + cellSize &&
            screenY >= -cellSize && screenY <= canvas.height + cellSize) {
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(screenX, screenY, cellSize / 4, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

// 繪製視窗內的敵人子彈
function drawEnemyBulletsInView(minX, maxX, minY, maxY) {
    enemyBullets.forEach(bullet => {
        const screenX = (bullet.x - cameraOffset.x) * cellSize;
        const screenY = (bullet.y - cameraOffset.y) * cellSize;
        
        if (screenX >= -cellSize && screenX <= canvas.width + cellSize &&
            screenY >= -cellSize && screenY <= canvas.height + cellSize) {
            ctx.fillStyle = '#e67e22';
            ctx.beginPath();
            ctx.arc(screenX, screenY, cellSize / 4, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

// 繪製視窗內的手榴彈
function drawGrenadeInView(minX, maxX, minY, maxY) {
    const screenX = (grenade.x - cameraOffset.x) * cellSize;
    const screenY = (grenade.y - cameraOffset.y) * cellSize;
    
    if (screenX >= -cellSize * 2 && screenX <= canvas.width + cellSize * 2 &&
        screenY >= -cellSize * 2 && screenY <= canvas.height + cellSize * 2) {
        ctx.fillStyle = '#27ae60';
        ctx.beginPath();
        ctx.arc(screenX, screenY, cellSize / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// 繪製視窗內的紅外瞄準線
function drawLaserSightInView(player) {
    const playerX = (player.x - cameraOffset.x) * cellSize;
    const playerY = (player.y - cameraOffset.y) * cellSize;
    
    let weaponRange;
    switch(player.weaponMode) {
        case 1: weaponRange = bulletSettings.pistol.range * cellSize; break;
        case 2: weaponRange = bulletSettings.auto.range * cellSize; break;
        case 3: weaponRange = bulletSettings.shotgun.range * cellSize; break;
    }

    const dx = mouseX - playerX;
    const dy = mouseY - playerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    let endX = playerX;
    let endY = playerY;
    let hitWall = false;
    
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    const xStep = dx / steps;
    const yStep = dy / steps;
    
    for (let i = 0; i <= steps && !hitWall; i++) {
        const testX = playerX + xStep * i;
        const testY = playerY + yStep * i;
        
        const currentDist = Math.sqrt((testX - playerX) ** 2 + (testY - playerY) ** 2);
        if (currentDist > weaponRange) break;
        
        const gridX = Math.floor((testX / cellSize) + cameraOffset.x);
        const gridY = Math.floor((testY / cellSize) + cameraOffset.y);
        
        if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            if (grid[gridY][gridX] === 'wall') {
                hitWall = true;
                endX = testX - xStep;
                endY = testY - yStep;
                break;
            }
        }
        
        endX = testX;
        endY = testY;
    }
    
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(playerX, playerY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
    ctx.beginPath();
    ctx.arc(endX, endY, 3, 0, Math.PI * 2);
    ctx.fill();
    
    if (distance > weaponRange) {
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.arc(playerX, playerY, weaponRange, player.angle - Math.PI/8, player.angle + Math.PI/8);
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

// 繪製視窗邊界
function drawViewportBorder() {
    // 繪製視窗邊界 - 調整為只繪製右邊框
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 2;
    
    // 只繪製右邊框
    ctx.beginPath();
    ctx.moveTo(viewportWidth * cellSize, 0);
    ctx.lineTo(viewportWidth * cellSize, viewportHeight * cellSize);
    ctx.stroke();
}



// Initialize image loader on page load
document.addEventListener('DOMContentLoaded', () => {
    
    initImageLoader();
    initBulletSettingsUI(); // 確保在頁面加載時初始化子彈設置
    // Add UI button for loading image (example)
    const loadButton = document.createElement('button');
    loadButton.textContent = 'Load Background Image';
    loadButton.onclick = loadBackgroundImage;
    document.body.appendChild(loadButton);

    // Add UI button for confirming image position
    const confirmButton = document.createElement('button');
    confirmButton.textContent = 'Confirm Image Position';
    confirmButton.onclick = confirmBackgroundImage;
    document.body.appendChild(confirmButton);
});



        function getRectCoords(start = rectStart) {
            if (!start) return { x: 0, y: 0, width: 0, height: 0 };
            const x1 = Math.min(start.x, start.currentX);
            const y1 = Math.min(start.y, start.currentY);
            const x2 = Math.max(start.x, start.currentX);
            const y2 = Math.max(start.y, start.currentY);
            return {
                x: x1,
                y: y1,
                width: x2 - x1 + 1,
                height: y2 - y1 + 1
            };
        }

        // 安全的 grid 存取輔助函數
function getGridCell(x, y) {
    const gridX = Math.floor(x);
    const gridY = Math.floor(y);
    
    if (gridY >= 0 && gridY < grid.length && 
        gridX >= 0 && gridX < grid[gridY].length) {
        return grid[gridY][gridX];
    }
    return 'wall'; // 超出邊界視為牆壁
}

function isColliding(x, y, isZombie = false, isBullet = false, checkPlayerCollision = false) {
    const gridX = Math.floor(x);
    const gridY = Math.floor(y);

    // 邊界檢查
    if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) {
        return isZombie; // 只有喪屍不能超出邊界
    }

    // 安全檢查
    if (!grid || !grid[gridY] || grid[gridY][gridX] === undefined) {
        console.error(`Invalid grid access at (${gridX}, ${gridY})`);
        return true;
    }

    // 傳送點檢查
    if (!isZombie && !isBullet && teleports.some(tp => 
        Math.floor(tp.x) === gridX && 
        Math.floor(tp.y) === gridY)
    ) {
        return false;
    }

    // 子彈碰撞
    if (isBullet) {
        const windowHit = windows.find(w => 
            Math.floor(w.x) === gridX && 
            Math.floor(w.y) === gridY
        );
        if (windowHit) {
            windowHit.health -= 25;
            windowHit.bulletHits++;
            if (windowHit.health <= 0) {
                windows = windows.filter(w => w !== windowHit);
            }
        }
            // 普通碰撞 (玩家可以穿過彈藥庫，所以不檢查彈藥庫碰撞)
    return grid[gridY][gridX] === 'wall' || 
           grid[gridY][gridX] === 'door' ||
           windows.some(w => Math.floor(w.x) === gridX && Math.floor(w.y) === gridY);
    }

    // 玩家碰撞
    if (checkPlayerCollision && isZombie) {
        const player = players[currentPlayerIndex];
        if (player && player.alive) {
            if (distance(x, y, player.x, player.y) < PLAYER_SETTINGS.collisionRadius) {
                return true;
            }
        }
    }

    // 喪屍碰撞
    if (isZombie) {
        const windowHit = windows.find(w => 
            Math.floor(w.x) === gridX && 
            Math.floor(w.y) === gridY
        );
        if (windowHit) return false;
        return grid[gridY][gridX] === 'wall' || grid[gridY][gridX] === 'door';
    }

    // 普通碰撞
    return grid[gridY][gridX] === 'wall' || 
           grid[gridY][gridX] === 'door' ||
           windows.some(w => Math.floor(w.x) === gridX && Math.floor(w.y) === gridY);
}

function updateWindows() {
    const now = Date.now();
    windows = windows.filter(win => {
        // 檢查是否有喪屍正在撞擊窗戶
        const isBeingHit = enemies.some(zombie => 
            zombie.type === 'zombie' &&
            Math.floor(zombie.x) === Math.floor(win.x) &&
            Math.floor(zombie.y) === Math.floor(win.y)
        );
        
        if (isBeingHit) {
            win.lastHitTime = now;
            // 喪屍撞擊每秒減少20耐久度
            win.health -= (now - win.lastHitTime) / 50;
        }
        
        // 耐久度耗盡或超過5秒被撞擊則消失
        return win.health > 0 && (now - win.lastHitTime < WINDOW_DURATION || !isBeingHit);
    });
}
// 新增視覺阻斷檢查（考慮窗戶等半透明障礙物）
function hasLineOfSight(x1, y1, x2, y2, ignoreDoors = false) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const steps = Math.max(Math.abs(dx), Math.abs(dy)) * 2;
    const xIncrement = dx / steps;
    const yIncrement = dy / steps;
    
    let x = x1;
    let y = y1;
    
    for (let i = 0; i <= steps; i++) {
        const gridX = Math.floor(x);
        const gridY = Math.floor(y);
        
        if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) {
            return false;
        }
        
        // 窗戶會部分阻擋視線（50%概率阻斷）
        const windowHere = windows.find(w => 
            Math.floor(w.x) === gridX && 
            Math.floor(w.y) === gridY
        );
        if (windowHere && Math.random() < 0.5) {
            return false;
        }
        
        // 牆壁和門檢查
        if (grid[gridY][gridX] === 'wall' || (!ignoreDoors && grid[gridY][gridX] === 'door')) {
            return false;
        }
        
        x += xIncrement;
        y += yIncrement;
    }
    
    return true;
}

function updatePlayer() {
    const player = players[currentPlayerIndex];
    if (!player || !player.alive) return;

    console.log(`玩家位置: x=${player.x.toFixed(2)}, y=${player.y.toFixed(2)}`); // 調試
    
        // 檢查是否被Licker抓住
    const isGrabbed = enemies.some(e => 
        e.tongue && e.tongue.target === player
    );
    
    if (isGrabbed) {
        player.isStunned = true; // 禁用玩家控制
    } else {
        player.isStunned = false;
        // 正常玩家更新...
    }
    // 1. 處理移動
    handleInput();

    // 2. 傳送檢查（僅當不在冷卻時）
    if (!player.isTeleporting) {
        console.log("檢查傳送..."); // 調試
        checkTeleport(player);
    } else {
        console.log("傳送冷卻中..."); // 調試
    }
}


function checkTeleport(player) {
    // 如果正在冷卻中則返回
    if (player.isTeleporting) return;
    
    const playerGridX = Math.floor(player.x);
    const playerGridY = Math.floor(player.y);
    
    // 檢查是否站在傳送點上
    const currentTeleport = teleports.find(tp => 
        Math.floor(tp.x) === playerGridX && 
        Math.floor(tp.y) === playerGridY
    );
    
    if (currentTeleport) {
        // 找到同組的所有其他傳送點
        const otherTeleports = teleports.filter(tp => 
            tp.pairId === currentTeleport.pairId && 
            !(tp.x === currentTeleport.x && tp.y === currentTeleport.y)
        );
        
        if (otherTeleports.length > 0) {
            // 確保傳送到配對的另一個點（A到B，B到A）
            let targetTeleport;
            if (currentTeleport.isA) {
                // 當前是A點，找B點
                targetTeleport = otherTeleports.find(tp => !tp.isA);
                // 如果找不到B點，就選擇第一個其他傳送點
                if (!targetTeleport) targetTeleport = otherTeleports[0];
            } else {
                // 當前是B點，找A點
                targetTeleport = otherTeleports.find(tp => tp.isA);
                // 如果找不到A點，就選擇第一個其他傳送點
                if (!targetTeleport) targetTeleport = otherTeleports[0];
            }
            
            if (targetTeleport) {
                executeTeleport(player, currentTeleport, targetTeleport);
            }
        }
    }
}

function executeTeleport(player, fromTeleport, toTeleport) {
    // 設置冷卻狀態和時間
    player.isTeleporting = true;
    player.lastTeleportTime = Date.now();
    
    // 執行傳送（確保在格子中心）
    player.x = toTeleport.x;
    player.y = toTeleport.y;
    
    // 更新遊戲狀態
    updateCamera(player);
    updateMousePosition(lastMousePos);
    updatePlayerAngle(player);
    
    // 傳送視覺效果
    const fromLabel = `${fromTeleport.pairId+1}${fromTeleport.isA ? 'A' : 'B'}`;
    const toLabel = `${toTeleport.pairId+1}${toTeleport.isA ? 'A' : 'B'}`;
    showStatusMessage(`從傳送點 ${fromLabel} 傳送到 ${toLabel}`, 'info');
    flashScreen(fromTeleport.color);
    
    // 立即重繪畫面
    drawGrid();
    
    // 冷卻結束提醒（1.5秒後）
    setTimeout(() => {
        if (players[currentPlayerIndex] === player) {
            showStatusMessage('傳送冷卻結束，可以再次傳送', 'success');
        }
        player.isTeleporting = false;
    }, 1500);
}

function initTeleportControls() {
    const controls = document.getElementById('controls');
    
    // 傳送點控制面板
    const teleportPanel = document.createElement('div');
    teleportPanel.className = 'controls-group';
    teleportPanel.innerHTML = `
        <h3>傳送點設置</h3>
        <div class="controls-row">
            <button id="placeTeleport" class="primary-btn">放置傳送點</button>
            <button id="newTeleportGroup" class="success-btn">新傳送組</button>
            <button id="clearTeleports" class="danger-btn">清除所有</button>
        </div>
        <div id="teleportGroupDisplay" style="margin-top:10px;padding:5px;background:#2c3e50;border-radius:5px;">
            當前組別: <span id="currentGroup">1</span>, 
            顏色: <span id="currentColor" style="color:${currentTeleportColor}">■</span>
            <span id="placingStatus">(放置A點)</span>
        </div>
    `;
    controls.appendChild(teleportPanel);
    

document.getElementById('confirmPathBtn').addEventListener('click', () => {
  if (currentPathEnemy && enemyPathPoints.length > 1) {
    currentPathEnemy.path = [...enemyPathPoints];
    showStatusMessage(`已為敵人設置 ${enemyPathPoints.length} 個路徑點`, 'success');
  }
});


document.getElementById('placeLickerBtn').addEventListener('click', () => {
    currentPlacement = 'licker';
});
    // 事件監聽
    document.getElementById('placeTeleport').addEventListener('click', () => {
        currentPlacement = 'teleport';
        showStatusMessage('點擊地圖放置傳送點 (先放A點，再放B點)', 'info');
    });
    
    document.getElementById('newTeleportGroup').addEventListener('click', () => {
        if (!placingTeleportA && teleportPairs[currentTeleportPairId]?.points?.length === 1) {
            showStatusMessage('請先完成當前組的B點放置！', 'error');
            return;
        }
        
        currentTeleportColor = getRandomFluorescentColor();
        currentTeleportPairId = Object.keys(teleportPairs).length;
        placingTeleportA = true;
        updateTeleportGroupDisplay();
        showStatusMessage(`已創建第 ${currentTeleportPairId+1} 組傳送點`, 'success');
    });
    
    document.getElementById('clearTeleports').addEventListener('click', () => {
        if (confirm('確定要清除所有傳送點嗎？')) {
            teleports = [];
            teleportPairs = {};
            currentTeleportPairId = 0;
            currentTeleportColor = getRandomFluorescentColor();
            placingTeleportA = true;
            updateTeleportGroupDisplay();
            showStatusMessage('已清除所有傳送點', 'success');
            drawGrid();
        }
    });
}
function updateMousePosition(event) {
    const rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;
    lastMousePos = { clientX: event.clientX, clientY: event.clientY };
}


function updateCamera(player) {
    cameraOffset.x = player.x - viewportWidth/2;
    cameraOffset.y = player.y - viewportHeight/2;
    
    // 確保攝像機不會超出地圖邊界
    cameraOffset.x = Math.max(0, Math.min(cameraOffset.x, gridSize - viewportWidth));
    cameraOffset.y = Math.max(0, Math.min(cameraOffset.y, gridSize - viewportHeight));
}
function flashScreen(color) {
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1.0;
    setTimeout(() => drawGrid(), 100);
}



// 修改後的 shootBullet 函數，應用新的子彈設置
function shootBullet(event) {
     console.log("當前武器速度倍數:", globalWeaponSpeedMultiplier); // 調試
    // 確保有存活的玩家
    if (players.length === 0 || !players[currentPlayerIndex].alive) return;
    
    const player = players[currentPlayerIndex];
    
    // 檢查射擊冷卻和裝彈狀態
    if (player.isReloading) return;
    if (Date.now() - player.lastShotTime < player.shootRate) return;
    if (player.ammo <= 0) {
        showStatusMessage('彈藥不足，請按 R 上彈！', 'error');
        return;
    }

    // 使用玩家當前角度
    const angle = player.angle || 0;
    
    // 根據武器類型設置參數
    let bulletCount = 1;
    let spreadAngle = 0;
    let bulletSpeed = 0.2;
    let bulletRange = 10;
    let bulletPenetration = 1;
    
    switch(player.weaponMode) {
        case 1: // 手枪
            player.shootRate = 200;
            bulletSpeed = bulletSettings.pistol.speed* globalWeaponSpeedMultiplier;
            bulletRange = bulletSettings.pistol.range;
            bulletPenetration = bulletSettings.pistol.penetration;
            break;
            
        case 2: // 自动
            player.shootRate = 100;
            bulletSpeed = bulletSettings.auto.speed* globalWeaponSpeedMultiplier;
            bulletRange = bulletSettings.auto.range;
            bulletPenetration = bulletSettings.auto.penetration;
            break;
            
        case 3: // 散弹
            player.shootRate = 400;
            bulletCount = 5;
            spreadAngle = Math.PI / 6;
            bulletSpeed = bulletSettings.shotgun.speed* globalWeaponSpeedMultiplier;
            bulletRange = bulletSettings.shotgun.range;
            bulletPenetration = bulletSettings.shotgun.penetration;
            break;
    }

    // 消耗彈藥
    player.ammo--;
    player.lastShotTime = Date.now();
    updateAmmoDisplay();

    // 生成子彈
    for (let i = 0; i < bulletCount; i++) {
        const angleOffset = (spreadAngle > 0) ? 
            (Math.random() - 0.5) * spreadAngle : 0;
        const finalAngle = angle + angleOffset;
        
        bullets.push({
            x: player.x,  // 從玩家當前位置發射
            y: player.y,
            dx: Math.cos(finalAngle) * bulletSpeed,
            dy: Math.sin(finalAngle) * bulletSpeed,
            distanceTraveled: 0,
            range: bulletRange,
            penetration: bulletPenetration,
            enemiesHit: 0
        });
    }
    
    // 調試信息
    console.log(`發射子彈: 位置(${player.x.toFixed(2)},${player.y.toFixed(2)}), 角度:${angle.toFixed(2)}`);
    console.log(`當前子彈數量: ${bullets.length}`);
}

// Modified autoShoot function to ensure consistency with shootBullet
// Modified autoShoot function to ensure consistency
function autoShoot(event) {
    if (players.length === 0 || !players[currentPlayerIndex].alive) return;

    const player = players[currentPlayerIndex];
    if ((player.weaponMode === 2 || player.weaponMode === 3) && Date.now() - player.lastShotTime > player.shootRate) {
        shootBullet(event);
    }
}

function enemyShoot(enemy) {
    if (enemy.type === 'zombie') return; // 殭屍不射擊

    const targetPlayer = findClosestPlayer(enemy);
    if (!targetPlayer || !targetPlayer.alive) return;

    // 嚴格檢查是否在視覺範圍內
    if (!isInEnemyVision(enemy, targetPlayer.x, targetPlayer.y)) {
        return; // 不在視覺範圍內則不射擊
    }

    const dx = targetPlayer.x - enemy.x;
    const dy = targetPlayer.y - enemy.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // 簡單射擊冷卻系統
    if (enemy.lastShot === undefined) enemy.lastShot = 0;
    const now = Date.now();
    
    if (now - enemy.lastShot > 1000) { // 1秒冷卻
        // 只有當敵人有視線看到玩家時才射擊
        if (hasLineOfSight(enemy.x, enemy.y, targetPlayer.x, targetPlayer.y)) {
            enemyBullets.push({
                x: enemy.x,
                y: enemy.y,
                dx: dx / dist * 0.2,
                dy: dy / dist * 0.2,
                firedBy: 'enemy'
            });
            enemy.lastShot = now;
            
            // 更新敵人朝向（面向射擊方向）
            enemy.angle = Math.atan2(dy, dx);
        }
    }
}


// 在敵人對象新增記憶屬性
class Enemy {
  constructor() {
    this.lastKnownPlayerPosition = null;
    this.lastSeenTime = 0;
    this.isInCombat = false;
  }
}

// 修改敵人的視覺檢測函數
function isInEnemyVision(enemy, targetX, targetY) {
    // 計算目標與敵人的距離
    const dx = targetX - enemy.x;
    const dy = targetY - enemy.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 如果超出敵人視覺範圍半徑，直接返回false
    if (distance > enemyVisionRange) return false;
    
    // 計算目標相對於敵人的角度
    let angleToTarget = Math.atan2(dy, dx);
    
    // 調整角度使其與敵人角度在同一範圍內
    while (angleToTarget - enemy.angle > Math.PI) angleToTarget -= Math.PI * 2;
    while (angleToTarget - enemy.angle < -Math.PI) angleToTarget += Math.PI * 2;
    
    // 檢查是否在視角範圍內
    if (Math.abs(angleToTarget - enemy.angle) > enemyVisionAngle / 2) return false;
    
    // 檢查是否有牆壁阻擋視線
    return hasLineOfSight(enemy.x, enemy.y, targetX, targetY);
}

function moveEnemy(enemy) {
    // 初始化速度
    if (enemy.speed === undefined) {
        enemy.speed = players[currentPlayerIndex].speed * 0.8 / cellSize;
    }
        // Licker 移動速度較慢
    if (enemy.type === ENEMY_TYPES.LICKER) {
        enemy.speed = players[currentPlayerIndex].speed * 0.5 / cellSize;
    } else {
        enemy.speed = players[currentPlayerIndex].speed * 0.8 / cellSize;
    }
    
    // Licker 不主動追擊玩家，除非玩家非常接近
    if (enemy.type === ENEMY_TYPES.LICKER) {
        const targetPlayer = findClosestPlayer(enemy);
        if (targetPlayer) {
            const dist = distance(enemy.x, enemy.y, targetPlayer.x, targetPlayer.y);
            if (dist > 5) { // 超出攻擊範圍就不動
                return;
            }
        }
    }

    // 檢查是否有玩家在視線內
    const targetPlayer = findClosestPlayer(enemy);
    const hasPlayerInSight = targetPlayer !== null; // 現在完全依賴findClosestPlayer的視覺檢查

    // 優先處理玩家在視線內的情況
    if (hasPlayerInSight) {
        // 重置路徑索引，以便返回路徑時能繼續
        enemy.lastPathIndex = enemy.currentPathIndex;
        enemy.currentPathIndex = undefined;
        
        const dx = targetPlayer.x - enemy.x;
        const dy = targetPlayer.y - enemy.y;
        const distToPlayer = Math.sqrt(dx * dx + dy * dy);

        // 更新敵人朝向（面向玩家）
        enemy.angle = Math.atan2(dy, dx);

        if (enemy.type === 'zombie') {
            moveZombie(enemy);
        } else {
            if (distToPlayer > 7) {
                // 追擊玩家
                const moveX = dx / distToPlayer * enemy.speed;
                const moveY = dy / distToPlayer * enemy.speed;
                
                if (!isColliding(enemy.x + moveX, enemy.y)) {
                    enemy.x += moveX;
                }
                if (!isColliding(enemy.x, enemy.y + moveY)) {
                    enemy.y += moveY;
                }
            } else if (distToPlayer <= 7) {
                // 射擊玩家
                enemyShoot(enemy);
            }
        }
        return;
    }

    // 沒有看到玩家時，按照路徑移動
    if (enemy.path && enemy.path.length > 1) {
        // 如果之前是在追擊玩家，回到最近的路徑點
        if (enemy.lastPathIndex !== undefined) {
            enemy.currentPathIndex = enemy.lastPathIndex;
            enemy.lastPathIndex = undefined;
        }
        followPath(enemy);
        
        // 更新敵人朝向（面向移動方向）
        if (enemy.path && enemy.currentPathIndex !== undefined) {
            const targetPoint = enemy.path[enemy.currentPathIndex];
            const targetX = targetPoint.x + 0.5;
            const targetY = targetPoint.y + 0.5;
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            enemy.angle = Math.atan2(dy, dx);
        }
    } else {
        // 如果沒有路徑，就在原地小範圍徘徊
        wanderRandomly(enemy);
    }
}


function followPath(enemy) {
    if (!enemy.path || enemy.path.length < 2) return;
    
    // 初始化路徑索引和方向
    if (enemy.currentPathIndex === undefined) {
        enemy.currentPathIndex = 0;
        enemy.pathDirection = 1; // 1:正向, -1:反向
    }
    
    // 獲取當前目標路徑點（使用格子中心坐標）
    const targetPoint = enemy.path[enemy.currentPathIndex];
    const targetX = targetPoint.x + 0.5;
    const targetY = targetPoint.y + 0.5;
    
    // 計算方向和距離
    const dx = targetX - enemy.x;
    const dy = targetY - enemy.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 如果非常接近當前路徑點，切換到下一個點
    if (distance < 0.05) { // 更小的閾值確保準確到達
        enemy.currentPathIndex += enemy.pathDirection;
        
        // 到達路徑端點時改變方向
        if (enemy.currentPathIndex >= enemy.path.length - 1) {
            enemy.pathDirection = -1; // 轉為反向移動
        } else if (enemy.currentPathIndex <= 0) {
            enemy.pathDirection = 1; // 轉為正向移動
        }
    } else {
        // 正常移動向當前路徑點
        const moveX = (dx / distance) * enemy.speed;
        const moveY = (dy / distance) * enemy.speed;
        
        // 分開檢測X和Y軸的碰撞
        let canMoveX = !isColliding(enemy.x + moveX, enemy.y);
        let canMoveY = !isColliding(enemy.x, enemy.y + moveY);
        
        // 如果某一方向被阻擋，嘗試另一方向
        if (!canMoveX && canMoveY) {
            enemy.y += moveY;
        } else if (canMoveX && !canMoveY) {
            enemy.x += moveX;
        } else if (canMoveX && canMoveY) {
            enemy.x += moveX;
            enemy.y += moveY;
        } else {
            // 兩個方向都被阻擋，嘗試跳到下一個路徑點
            enemy.currentPathIndex += enemy.pathDirection;
        }
    }
}

// 修改敵人的視覺繪製（可選，用於調試）
function drawEnemyVision(enemy, screenX, screenY) {
    const radius = enemyVisionRange * cellSize;
    const targetPlayer = findClosestPlayer(enemy);
    const hasTarget = targetPlayer !== null;
    
    ctx.save(); // 保存當前繪製狀態
    
    // 視覺扇形填充
    const baseAlpha = testMode ? 0.1 : 0.15;
    ctx.fillStyle = hasTarget ? `rgba(255, 50, 50, ${baseAlpha})` : `rgba(255, 0, 0, ${baseAlpha})`;
    ctx.beginPath();
    ctx.moveTo(screenX, screenY);
    ctx.arc(screenX, screenY, radius, enemy.angle - enemyVisionAngle/2, enemy.angle + enemyVisionAngle/2);
    ctx.closePath();
    ctx.fill();

    // 視覺邊界線
    const borderAlpha = testMode ? 0.2 : 0.3;
    ctx.strokeStyle = `rgba(255, 100, 100, ${borderAlpha})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(screenX, screenY);
    ctx.lineTo(screenX + Math.cos(enemy.angle - enemyVisionAngle/2) * radius, 
               screenY + Math.sin(enemy.angle - enemyVisionAngle/2) * radius);
    ctx.moveTo(screenX, screenY);
    ctx.lineTo(screenX + Math.cos(enemy.angle + enemyVisionAngle/2) * radius, 
               screenY + Math.sin(enemy.angle + enemyVisionAngle/2) * radius);
    ctx.stroke();

    // 視覺範圍外圈（虛線效果）
    ctx.setLineDash([3, 3]); // 設定為虛線
    ctx.beginPath();
    ctx.arc(screenX, screenY, radius, enemy.angle - enemyVisionAngle/2, enemy.angle + enemyVisionAngle/2);
    ctx.stroke();
    ctx.setLineDash([]); // 必須重置為實線！ ← 這行絕不能刪除

    ctx.restore(); // 恢復繪製狀態
}



function wanderRandomly(enemy) {
    // 初始化徘徊計數器
    if (enemy.wanderCounter === undefined) {
        enemy.wanderCounter = 0;
        enemy.wanderTarget = {
            x: enemy.x + (Math.random() * 2 - 1),
            y: enemy.y + (Math.random() * 2 - 1)
        };
    }
    
    // 更新目標位置
    enemy.wanderCounter++;
    if (enemy.wanderCounter > 60 || 
        Math.abs(enemy.x - enemy.wanderTarget.x) < 0.1 && 
        Math.abs(enemy.y - enemy.wanderTarget.y) < 0.1) {
        enemy.wanderCounter = 0;
        enemy.wanderTarget = {
            x: enemy.x + (Math.random() * 2 - 1),
            y: enemy.y + (Math.random() * 2 - 1)
        };
    }
    
    // 移動向目標位置
    const dx = enemy.wanderTarget.x - enemy.x;
    const dy = enemy.wanderTarget.y - enemy.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > 0) {
        const moveX = (dx / dist) * enemy.speed * 0.5; // 徘徊速度減半
        const moveY = (dy / dist) * enemy.speed * 0.5;
        
        if (!isColliding(enemy.x + moveX, enemy.y)) {
            enemy.x += moveX;
        }
        if (!isColliding(enemy.x, enemy.y + moveY)) {
            enemy.y += moveY;
        }
    }
}



// 輔助函數：尋找最近玩家
function findClosestPlayer(enemy) {
    let targetPlayer = null;
    let minDist = Infinity;
    
    players.forEach(player => {
        if (player.alive) {
            const dist = distance(enemy.x, enemy.y, player.x, player.y);
            // 必須同時滿足：在視覺範圍內 且 有直接視線
            const canSee = isInEnemyVision(enemy, player.x, player.y) && 
                         hasLineOfSight(enemy.x, enemy.y, player.x, player.y);
            
            if (dist < minDist && canSee) {
                minDist = dist;
                targetPlayer = player;
            }
        }
    });
    
    return targetPlayer;
}


function initVisionGrid() {
    visionGrid = Array(Math.ceil(gridSize / visionGridSize)).fill()
        .map(() => Array(Math.ceil(gridSize / visionGridSize)).fill().map(() => []));
}

function updateVisionGrid() {
    // 清空網格
    initVisionGrid();
    
    
}

function updateZombieBehavior() {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || !currentPlayer.alive) return;

    // 更新空間網格
    updateVisionGrid();
    
    // 獲取玩家所在網格及相鄰網格
    const playerGridX = Math.floor(currentPlayer.x / visionGridSize);
    const playerGridY = Math.floor(currentPlayer.y / visionGridSize);
    
    // 檢查3x3區域內的喪屍
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            const gridX = playerGridX + dx;
            const gridY = playerGridY + dy;
            
            if (gridX >= 0 && gridX < visionGrid.length && 
                gridY >= 0 && gridY < visionGrid[0].length) {
                
                visionGrid[gridX][gridY].forEach(zombie => {
                    if (zombie.type === 'zombie') {
                        handleZombieDetection(zombie, currentPlayer);
                    }
                });
            }
        }
    }
}



function handleZombieDetection(zombie, player) {
    // 計算與玩家的距離
    const dx = player.x - zombie.x;
    const dy = player.y - zombie.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 檢查是否在視覺範圍內且有視線
    if (distance <= 5 * cellSize && hasLineOfSight(zombie.x, zombie.y, player.x, player.y)) {
        // 喪屍發現玩家 - 使用群體行為規則
        zombie.detectedPlayer = true;
        zombie.targetX = player.x;
        zombie.targetY = player.y;
        
        // 應用分離行為防止重疊
        applySeparationBehavior(zombie);
    } else {
        zombie.detectedPlayer = false;
        // 恢復巡邏行為或閒置狀態
        if (zombie.path && zombie.path.length > 0) {
            followPath(zombie);
        }
    }
    
    // 更新喪屍位置
    if (zombie.detectedPlayer) {
        moveZombieToPlayer(zombie);
    }
}

function applySeparationBehavior(zombie) {
    const separationRadius = 3; // 增加分離半徑
    let separationForce = { x: 0, y: 0 };
    let neighborCount = 0;
    
    // 檢查3x3區域內的網格而不只是當前網格
    const gridX = Math.floor(zombie.x / visionGridSize);
    const gridY = Math.floor(zombie.y / visionGridSize);
    
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            const checkX = gridX + dx;
            const checkY = gridY + dy;
            
            if (checkX >= 0 && checkX < visionGrid.length && 
                checkY >= 0 && checkY < visionGrid[0].length) {
                
                visionGrid[checkX][checkY].forEach(other => {
                    if (other !== zombie) {
                        const dist = distance(zombie.x, zombie.y, other.x, other.y);
                        if (dist < separationRadius) {
                            const repelX = (zombie.x - other.x) / dist;
                            const repelY = (zombie.y - other.y) / dist;
                            separationForce.x += repelX * (1 - dist/separationRadius);
                            separationForce.y += repelY * (1 - dist/separationRadius);
                            neighborCount++;
                        }
                    }
                });
            }
        }
    }
    
    if (neighborCount > 0) {
        separationForce.x /= neighborCount;
        separationForce.y /= neighborCount;
        
        const maxForce = 0.3; // 增加最大分離力
        const forceMagnitude = Math.sqrt(separationForce.x * separationForce.x + separationForce.y * separationForce.y);
        if (forceMagnitude > maxForce) {
            separationForce.x = separationForce.x / forceMagnitude * maxForce;
            separationForce.y = separationForce.y / forceMagnitude * maxForce;
        }
        
        // 將分離力作為優先考慮，先應用分離再移動向玩家
        zombie.x += separationForce.x;
        zombie.y += separationForce.y;
    }
}


function applyGlobalSeparation(zombie) {
    const separationRadius = 4; // 更大的分離半徑
    const personalSpace = 1.2; // 個體最小間距
    let totalForce = { x: 0, y: 0 };
    
    // 檢查所有附近的喪屍（不只是同網格）
    const nearbyZombies = getNearbyEntities(zombie, separationRadius, 'zombie');
    
    nearbyZombies.forEach(other => {
        const dist = distance(zombie.x, zombie.y, other.x, other.y);
        if (dist < personalSpace) {
            // 強力排斥
            const force = (personalSpace - dist) / dist;
            totalForce.x += (zombie.x - other.x) * force;
            totalForce.y += (zombie.y - other.y) * force;
        }
    });
    
    // 應用分離力
    if (nearbyZombies.length > 0) {
        const maxForce = 0.5;
        const magnitude = Math.sqrt(totalForce.x * totalForce.x + totalForce.y * totalForce.y);
        if (magnitude > 0) {
            const scale = Math.min(maxForce, magnitude) / magnitude;
            zombie.x += totalForce.x * scale;
            zombie.y += totalForce.y * scale;
            
            // 確保不會卡在障礙物中
            if (isColliding(zombie.x, zombie.y)) {
                // 嘗試調整位置
                zombie.x -= totalForce.x * scale * 0.5;
                zombie.y -= totalForce.y * scale * 0.5;
            }
        }
    }
}


function updateSpatialGrid() {
    // 清空網格
    for (const key in spatialGrid) {
        delete spatialGrid[key];
    }
    
    // 將所有實體放入網格
    [...players, ...enemies].forEach(entity => {
        const gridX = Math.floor(entity.x / SPATIAL_GRID_SIZE);
        const gridY = Math.floor(entity.y / SPATIAL_GRID_SIZE);
        const gridKey = `${gridX},${gridY}`;
        
        if (!spatialGrid[gridKey]) {
            spatialGrid[gridKey] = [];
        }
        spatialGrid[gridKey].push(entity);
    });
}


function getNearbyEntities(x, y, radius) {
    const result = [];
    const startGridX = Math.floor((x - radius) / SPATIAL_GRID_SIZE);
    const startGridY = Math.floor((y - radius) / SPATIAL_GRID_SIZE);
    const endGridX = Math.floor((x + radius) / SPATIAL_GRID_SIZE);
    const endGridY = Math.floor((y + radius) / SPATIAL_GRID_SIZE);
    
    for (let gx = startGridX; gx <= endGridX; gx++) {
        for (let gy = startGridY; gy <= endGridY; gy++) {
            const gridKey = `${gx},${gy}`;
            if (spatialGrid[gridKey]) {
                result.push(...spatialGrid[gridKey]);
            }
        }
    }
    
    return result.filter(e => distance(x, y, e.x, e.y) <= radius);
}

function optimizedIsColliding(x, y, isZombie = false, isBullet = false) {
    const gridX = Math.floor(x);
    const gridY = Math.floor(y);
    
    // 邊界檢查 (快速失敗)
    if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) {
        return isZombie;
    }
    
    // 快速牆體檢查
    if (grid[gridY][gridX] === 'wall') return true;
    
    // 子彈特殊處理
    if (isBullet) {
        const windowHit = windows.find(w => 
            Math.floor(w.x) === gridX && 
            Math.floor(w.y) === gridY
        );
        if (windowHit) {
            windowHit.health -= 25;
            if (windowHit.health <= 0) {
                windows.splice(windows.indexOf(windowHit), 1);
            }
        }
        return false;
    }
    
    // 門檢查
    if (grid[gridY][gridX] === 'door') return true;
    
    // 窗戶檢查 (緩存優化)
    if (!isZombie) {
        for (let i = 0; i < windows.length; i++) {
            const w = windows[i];
            if (Math.floor(w.x) === gridX && Math.floor(w.y) === gridY) {
                return true;
            }
        }
    }
    
    return false;
}

function checkPlayerZombieCollision() {
    const player = players[currentPlayerIndex];
    if (!player || !player.alive) return;
    
    // 使用空間網格只檢查附近的喪屍
    const nearbyZombies = getNearbyEntities(player.x, player.y, 3);
    
    for (const zombie of nearbyZombies) {
        if (zombie.type === 'zombie') {
            const dist = distance(player.x, player.y, zombie.x, zombie.y);
            if (dist < PLAYER_SETTINGS.collisionRadius) {
                // 處理玩家被攻擊邏輯
                player.health = 0;
                player.alive = false;
                updatePlayersDisplay();
                checkPlayerSwitch();
                return;
            }
        }
    }
}

function calculateSeparation(zombie) {
    const separationForce = { x: 0, y: 0 };
    let neighborCount = 0;
    
    // 获取附近所有丧尸
    const nearbyZombies = getNearbyZombies(zombie);
    
    nearbyZombies.forEach(other => {
        // 计算与邻近丧尸的距离
        const dist = distance(zombie.x, zombie.y, other.x, other.y);
        
        // 如果在个人空间范围内
        if (dist > 0 && dist < ZOMBIE_SETTINGS.personalSpace) {
            // 计算排斥力 (与距离成反比)
            const repelStrength = (ZOMBIE_SETTINGS.personalSpace - dist) / dist;
            separationForce.x += (zombie.x - other.x) * repelStrength;
            separationForce.y += (zombie.y - other.y) * repelStrength;
            neighborCount++;
        }
    });
    
    // 计算平均分离力
    if (neighborCount > 0) {
        separationForce.x /= neighborCount;
        separationForce.y /= neighborCount;
        
        // 限制最大分离力
        const magnitude = Math.sqrt(separationForce.x * separationForce.x + separationForce.y * separationForce.y);
        if (magnitude > ZOMBIE_SETTINGS.maxSeparationForce) {
            separationForce.x = (separationForce.x / magnitude) * ZOMBIE_SETTINGS.maxSeparationForce;
            separationForce.y = (separationForce.y / magnitude) * ZOMBIE_SETTINGS.maxSeparationForce;
        }
    }
    
    return separationForce;
}

function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}

function getNearbyZombies(zombie) {
    const result = [];
    const gridX = Math.floor(zombie.x / visionGridSize);
    const gridY = Math.floor(zombie.y / visionGridSize);
    const searchRadius = Math.ceil(ZOMBIE_SETTINGS.separationRadius / visionGridSize);
    
    // 检查3x3或更大范围的网格
    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
            const checkX = gridX + dx;
            const checkY = gridY + dy;
            
            if (checkX >= 0 && checkX < visionGrid.length && 
                checkY >= 0 && checkY < visionGrid[0].length) {
                
                visionGrid[checkX][checkY].forEach(other => {
                    if (other !== zombie && other.type === 'zombie') {
                        const dist = distance(zombie.x, zombie.y, other.x, other.y);
                        if (dist <= ZOMBIE_SETTINGS.separationRadius) {
                            result.push(other);
                        }
                    }
                });
            }
        }
    }
    return result;
}

// 增強版碰撞檢測
function checkZombiePlayerCollision(zombie, player) {
    const dist = distance(zombie.x, zombie.y, player.x, player.y);
    
    // 檢查是否達到吃掉距離
    if (dist < PLAYER_SETTINGS.eatDistance) {
        player.health = 0;
        player.alive = false;
        updatePlayersDisplay();
        checkPlayerSwitch();
        return true;
    }
    
    // 檢查是否碰撞(用於移動阻擋)
    return dist < PLAYER_SETTINGS.collisionRadius;
}

function moveZombieToPlayer(zombie) {
    const player = players[currentPlayerIndex];
    if (!player || !player.alive) return;

    // 先檢查是否可以吃掉玩家
    if (checkZombiePlayerCollision(zombie, player)) {
        return; // 已處理吃掉邏輯
    }

    const dx = player.x - zombie.x;
    const dy = player.y - zombie.y;
    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
    
    if (distToPlayer > 0) {
        // 基礎移動向量(加大步長)
        let moveX = (dx / distToPlayer) * ZOMBIE_SETTINGS.baseSpeed * 1.5;
        let moveY = (dy / distToPlayer) * ZOMBIE_SETTINGS.baseSpeed * 1.5;
        
        // 計算分離力(減少影響權重)
        const separation = calculateSeparation(zombie);
        moveX += separation.x * 0.3;  // 降低分離力影響
        moveY += separation.y * 0.3;
        
        // 確保移動方向仍朝向玩家
        const dotProduct = (moveX * dx + moveY * dy) / (distToPlayer * Math.sqrt(moveX*moveX + moveY*moveY));
        if (dotProduct < 0.7) { // 如果偏離太多
            moveX = (dx / distToPlayer) * ZOMBIE_SETTINGS.baseSpeed * 1.2;
            moveY = (dy / distToPlayer) * ZOMBIE_SETTINGS.baseSpeed * 1.2;
        }
        
        // 嘗試移動(放寬碰撞檢測)
        const newX = zombie.x + moveX;
        const newY = zombie.y + moveY;
        
        if (!isColliding(newX, zombie.y, false) || 
            distance(newX, zombie.y, player.x, player.y) < PLAYER_SETTINGS.collisionRadius) {
            zombie.x = newX;
        }
        
        if (!isColliding(zombie.x, newY, false) || 
            distance(zombie.x, newY, player.x, player.y) < PLAYER_SETTINGS.collisionRadius) {
            zombie.y = newY;
        }
        
        // 再次檢查碰撞(移動後)
        checkZombiePlayerCollision(zombie, player);
    }
}


function moveZombie(zombie) {
    let targetPlayer = null;
    let minDist = Infinity;
    
    // 尋找最近的玩家（可以透視門）
    players.forEach(player => {
        if (player.alive) {
            const dist = Math.sqrt(Math.pow(zombie.x - player.x, 2) + Math.pow(zombie.y - player.y, 2));
            if (dist < minDist && hasLineOfSight(zombie.x, zombie.y, player.x, player.y, true)) {
                minDist = dist;
                targetPlayer = player;
            }
        }
    });
    
    if (!targetPlayer || minDist > 25) return;
    
    // 如果距離玩家很近（<0.5），則吃掉玩家
    if (minDist < 0.5) {
        targetPlayer.health = 0;
        targetPlayer.alive = false;
        updatePlayersDisplay();
        checkPlayerSwitch();
        return;
    }
    
    // 計算移動方向（不能穿過門）
    const dx = targetPlayer.x - zombie.x;
    const dy = targetPlayer.y - zombie.y;
    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
    const speed = players[currentPlayerIndex].speed * 3 / cellSize;
    
    // 嘗試移動（考慮門的碰撞）
    const newX = zombie.x + dx / distToPlayer * speed;
    const newY = zombie.y + dy / distToPlayer * speed;
    
    // 檢查是否撞到窗戶
    const newGridX = Math.floor(newX);
    const newGridY = Math.floor(newY);
    const hitWindow = windows.find(w => 
        Math.floor(w.x) === newGridX && 
        Math.floor(w.y) === newGridY
    );
    
    if (hitWindow) {
        const now = Date.now();
        // 如果這是喪屍第一次撞擊這個窗戶，記錄時間
        if (hitWindow.lastHitTime === 0) {
            hitWindow.lastHitTime = now;
        }
        
        // 每秒減少20耐久度 (5秒完全破壞)
        hitWindow.health -= (now - hitWindow.lastHitTime) * 0.02;
        hitWindow.lastHitTime = now;
        
        // 如果窗戶耐久度耗盡，移除窗戶
        if (hitWindow.health <= 0) {
            windows = windows.filter(w => w !== hitWindow);
        }
        return; // 喪屍暫時停在窗戶前
    }
    
    // 正常移動（避開牆和門）
    if (!isColliding(newX, zombie.y, true)) zombie.x = newX;
    if (!isColliding(zombie.x, newY, true)) zombie.y = newY;
}

// Modified throwGrenade function to initialize grenade aiming

function throwGrenade(event) {
    if (players.length === 0 || !players[currentPlayerIndex].alive) return;

    const player = players[currentPlayerIndex];
    if (player.grenadeCount <= 0) {
        showStatusMessage('無手榴彈可用！', 'error');
        return;
    }

    if (grenade && (!grenade.thrown || grenade.progress < 1)) return;

    const rect = canvas.getBoundingClientRect();
    // 計算鼠標在遊戲世界中的位置（考慮攝像機偏移）
    let mouseWorldX = (event.clientX - rect.left) / cellSize + cameraOffset.x;
    let mouseWorldY = (event.clientY - rect.top) / cellSize + cameraOffset.y;

    // 計算與玩家的距離
    const dx = mouseWorldX - player.x;
    const dy = mouseWorldY - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // 限制最大投擲距離
    const maxRange = bulletSettings.grenadeRange;
    let targetX = mouseWorldX;
    let targetY = mouseWorldY;

    if (dist > maxRange) {
        const scale = maxRange / dist;
        targetX = player.x + dx * scale;
        targetY = player.y + dy * scale;
    } else if (dist < 0.1) {
        // 防止零距離
        targetX = player.x + 0.1;
        targetY = player.y;
    }

    grenade = {
        x: player.x,
        y: player.y,
        targetX: targetX,
        targetY: targetY,
        progress: 0,
        thrown: false,
        // 計算初始速度向量（確保方向準確）
        dx: (targetX - player.x) / 10,
        dy: (targetY - player.y) / 10
    };
}


// Modified updateGrenadeTarget function to update aim within 10-grid radius

function updateGrenadeTarget(event) {
    if (aiming && gameState === 'playing' && grenade && !grenade.thrown) {
        const player = players[currentPlayerIndex];
        const rect = canvas.getBoundingClientRect();
        
        // 計算鼠標在遊戲世界中的位置（考慮攝像機偏移）
        let mouseWorldX = (event.clientX - rect.left) / cellSize + cameraOffset.x;
        let mouseWorldY = (event.clientY - rect.top) / cellSize + cameraOffset.y;

        // 計算與玩家的距離
        const dx = mouseWorldX - player.x;
        const dy = mouseWorldY - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // 限制最大投擲距離
        const maxRange = bulletSettings.grenadeRange;
        let targetX = mouseWorldX;
        let targetY = mouseWorldY;

        if (dist > maxRange) {
            const scale = maxRange / dist;
            targetX = player.x + dx * scale;
            targetY = player.y + dy * scale;
        } else if (dist < 0.1) {
            // 防止零距離
            targetX = player.x + 0.1;
            targetY = player.y;
        }

        // 更新手榴彈目標位置
        grenade.targetX = targetX;
        grenade.targetY = targetY;
        grenade.dx = (targetX - player.x) / 50;
        grenade.dy = (targetY - player.y) / 50;
        
        drawGrid();
    }
}


        function openDoor() {
            try {
                if (players.length === 0 || !players[currentPlayerIndex].alive) return;
                
                const player = players[currentPlayerIndex];
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                let doorOpened = false;
                for (const [dx, dy] of directions) {
                    const x = Math.floor(player.x + dx);
                    const y = Math.floor(player.y + dy);
                    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize && grid[y][x] === 'door') {
                        grid[y][x] = 'empty';
                        savedGrid[y][x] = 'empty';
                        doorOpened = true;
                    }
                }
                if (doorOpened) drawGrid();
            } catch (error) {
                console.error('開門錯誤:', error);
            }
        }

function gameOver(reason) {
    gameOverReason.textContent = reason;
    gameOverScreen.classList.remove('hidden');
    gameState = 'gameOver';
    
    // 恢復遊戲前的所有狀態（包括玩家和喪屍）
    if (savedGrid) {
        grid = savedGrid.map(row => [...row]);
    }
    if (savedEnemies) {
        enemies = JSON.parse(JSON.stringify(savedEnemies));
    }
    if (savedDefenseAreas) {
        defenseAreas = JSON.parse(JSON.stringify(savedDefenseAreas));
    }
    if (savedPlayers) {  // 新增：恢復保存的玩家狀態
        players = JSON.parse(JSON.stringify(savedPlayers));
    }
    
    // 切換回編輯模式
    isEditMode = true;
    setupControls.style.display = 'block';
    weaponInfo.style.display = 'none';
    playerInfo.style.display = 'none';
    
    // 重置遊戲元素
    bullets = [];
    enemyBullets = [];
    grenade = null;
    
    resizeCanvas();
    drawGrid();
    
    showStatusMessage('遊戲結束，已返回編輯模式', 'info');
}

function checkPlayerSwitch() {
    if (noRegularPlayersAlive()) {
        return handleNoRegularPlayers();
    }
    
    if (currentPlayerDeadOrCompanion()) {
        return switchToNextAvailablePlayer();
    }
    
    return false;
}

function noRegularPlayersAlive() {
    return players.filter(p => p.alive && !p.isCompanion).length === 0;
}

function currentPlayerDeadOrCompanion() {
    return !players[currentPlayerIndex].alive || players[currentPlayerIndex].isCompanion;
}

function handleNoRegularPlayers() {
    const aliveCompanions = players.filter(p => p.alive && p.isCompanion);
    
    if (aliveCompanions.length > 0) {
        promoteCompanionToPlayer(aliveCompanions[0]);
        return false;
    } else {
        gameOver('所有玩家都已死亡!');
        return true;
    }
}

function promoteCompanionToPlayer(companion) {
    companion.isCompanion = false;
    companion.companionOf = null;
    currentPlayerIndex = players.indexOf(companion);
    updatePlayersDisplay();
    showStatusMessage('主要玩家已死亡，現在控制同伴繼續遊戲!', 'warning');
}

function switchToNextAvailablePlayer() {
    const nextPlayerIndex = findNextRegularPlayer();
    
    if (nextPlayerIndex >= 0) {
        switchToPlayer(nextPlayerIndex);
        return false;
    } else {
        return handleNoRegularPlayers();
    }
}

function findNextRegularPlayer() {
    return players.findIndex((p, i) => 
        i !== currentPlayerIndex && p.alive && !p.isCompanion
    );
}

function switchToPlayer(playerIndex) {
    currentPlayerIndex = playerIndex;
    updatePlayersDisplay();
    showStatusMessage(`切換到玩家 ${currentPlayerIndex + 1}`, 'info');
}
// Modified checkGameOver function to ensure proper game termination
function checkGameOver() {
    for (const bullet of enemyBullets) {
        for (let i = 0; i < players.length; i++) {
            const player = players[i];
            if (!player.alive) continue;
            
            const dist = Math.sqrt((bullet.x - player.x) ** 2 + (bullet.y - player.y) ** 2);
            if (dist < 0.3) {
                player.health -= 25;
                if (player.health <= 0) {
                    player.alive = false;
                }
                updatePlayersDisplay();
                
                if (i === currentPlayerIndex) {
                    if (checkPlayerSwitch()) {
                        return true;
                    }
                }
                
                enemyBullets.splice(enemyBullets.indexOf(bullet), 1);
                break;
            }
        }
    }
    
    const alivePlayers = players.filter(p => p.alive);
    if (alivePlayers.length === 0) {
        gameOver('所有玩家都已死亡!');
        return true;
    }
    
    // Only end game if all enemies are eliminated
    if (enemies.length === 0) {
        console.log(`Game over: No enemies remain. Total enemies: ${enemies.length}`);
        gameOver('恭喜! 你消滅了所有敵人!');
        return true;
    }
    
    for (const zombie of enemies) {
        if (zombie.type !== 'zombie') continue;
        
        for (const area of defenseAreas) {
            const x = Math.floor(zombie.x);
            const y = Math.floor(zombie.y);
            
            if (x >= area.x && x < area.x + area.width &&
                y >= area.y && y < area.y + area.height) {
                gameOver('殭屍入侵攻防區域!');
                return true;
            }
        }
    }
    
    return false;
}

function updateAmmoDisplay() {
    try {
        const player = players.length > 0 && players[currentPlayerIndex]?.alive ? players[currentPlayerIndex] : null;
        if (!player) {
            currentAmmoDisplay.textContent = '';
            totalAmmoDisplay.textContent = '';
            const grenadeElement = document.getElementById('grenadeCountDisplay');
            if (grenadeElement) {
                grenadeElement.textContent = '';
            }
            return;
        }

        currentAmmoDisplay.textContent = player.ammo;
        totalAmmoDisplay.textContent = player.totalAmmo;
        const grenadeElement = document.getElementById('grenadeCountDisplay');
        if (grenadeElement) {
            grenadeElement.textContent = player.grenadeCount;
        }
    } catch (error) {
        console.error('更新武器狀態顯示錯誤:', error);
        showStatusMessage('更新武器顯示失敗', 'error');
    }
}

// Modified updateGame function to handle grenade explosion

// 明确的游戏循环函数
function gameLoop() {
    try {
        // 1. 处理输入
        handleInput();
        
        // 2. 更新游戏状态
        updateGameState();
        
        // 3. 渲染
        drawGrid();
        checkAmmoDepotCollision();
        // 4. 继续循环
        if (gameState === 'playing') {
            requestAnimationFrame(gameLoop);
        }
    } catch (error) {
        console.error('游戏循环错误:', error);
        showStatusMessage(`游戏循环错误: ${error.message}`, 'error');
        setTimeout(gameLoop, 1000); // 尝试恢复
    }
}


function handleInput() {
    const player = players[currentPlayerIndex];
    if (!player || !player.alive || !player.canMove) return;

    // 檢查按鍵狀態 (SHIFT衝刺 / C慢速)
    player.isSprinting = keys.shift && player.stamina > 0 && !keys.c;
    player.isSlowWalking = keys.c && player.stamina > 0 && !keys.shift;

    // 根據移動狀態決定速度
    let currentSpeed;
    if (player.isSprinting) {
        currentSpeed = player.sprintSpeed;
    } else if (player.isSlowWalking) {
        currentSpeed = player.slowSpeed;
    } else {
        currentSpeed = player.speed;
    }

    let vx = 0, vy = 0;
    if (keys.w) vy -= currentSpeed;
    if (keys.s) vy += currentSpeed;
    if (keys.a) vx -= currentSpeed;
    if (keys.d) vx += currentSpeed;

    // 對角線移動標準化
    if (vx !== 0 && vy !== 0) {
        vx *= 0.707;
        vy *= 0.707;
    }

    // 計算新位置
    const newX = player.x + vx / cellSize;
    const newY = player.y + vy / cellSize;

    // 檢查碰撞
    if (!isColliding(newX, player.y, false, false, false)) {
        player.x = newX;
    }
    if (!isColliding(player.x, newY, false, false, false)) {
        player.y = newY;
    }

    // 更新玩家角度
    updatePlayerAngle(player);

    // 更新體力值
    updateStamina(player);

    // 添加這行 - 在玩家移動後立即檢查彈藥庫碰撞
    checkAmmoDepotCollision();
}


// 新增體力更新函數
function updateStamina(player) {
    const now = Date.now();
    if (now - player.lastStaminaUpdate < 100) return; // 每100ms更新一次

    if (player.isSprinting) {
        // 衝刺時消耗體力 (較快)
        player.stamina = Math.max(0, player.stamina - 2);
    } else if (player.isSlowWalking) {
        // 慢速行走時消耗體力 (較慢)
        player.stamina = Math.max(0, player.stamina - 1);
    } else {
        // 正常行走時恢復體力
        player.stamina = Math.min(100, player.stamina + 1);
    }

    player.lastStaminaUpdate = now;
}



function resolveZombieCollisions() {
    const collisionThreshold = 0.8; // 碰撞判定距離
    
    for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
            const z1 = enemies[i];
            const z2 = enemies[j];
            
            if (z1.type === 'zombie' && z2.type === 'zombie') {
                const dist = distance(z1.x, z1.y, z2.x, z2.y);
                if (dist < collisionThreshold) {
                    // 計算排斥方向
                    const angle = Math.atan2(z2.y - z1.y, z2.x - z1.x);
                    const force = (collisionThreshold - dist) * 0.5;
                    
                    // 互相推開
                    z1.x -= Math.cos(angle) * force;
                    z1.y -= Math.sin(angle) * force;
                    z2.x += Math.cos(angle) * force;
                    z2.y += Math.sin(angle) * force;
                }
            }
        }
    }
}
// 分解updateGame()的功能
function updateGameState() {
    // 原updateGame()中的状态更新逻辑
    updatePlayer();
    updateZombieBehavior(); // 添加這行
    updateCompanionSystem();
    updateEnemies();
    // 專門處理喪屍-玩家交互
    handleZombiePlayerInteractions();
        // 添加這行 - 在玩家更新後檢查彈藥庫碰撞
    checkAmmoDepotCollision();

    // 檢查 Licker 攻擊
    if (gameState === 'playing') {
        enemies.forEach(enemy => {
            if (enemy.type === ENEMY_TYPES.LICKER) {
                updateLickerAttack(enemy);
            }
        });
    }


    resolveZombieCollisions(); // 新增這行
    updateBullets();
    updateEnemyBullets();
    updateGrenade();
    updateWindows();
    checkReloadStatus();
    checkCollisions();
    updateCompanionSystem();


    
    // 检查游戏结束
    if (checkGameOver()) {
        return;
    }
}


// Licker 攻擊邏輯
function updateLickerAttack(licker) {
    // 攻擊冷卻
    if (licker.attackCooldown > 0) {
        licker.attackCooldown--;
        return;
    }
    
    // 檢查玩家是否在範圍內
    players.forEach(player => {
        if (!player.alive) return;
        
        const dist = distance(licker.x, licker.y, player.x, player.y);
        if (dist <= 5 && hasLineOfSight(licker.x, licker.y, player.x, player.y)) {
            // 發動攻擊
            lickerAttack(licker, player);
            licker.attackCooldown = 120; // 2秒冷卻 (60fps)
        }
    });
}

function lickerAttack(licker, player) {
    // 繪製舌頭動畫
    licker.tongue = {
        startX: licker.x,
        startY: licker.y,
        endX: player.x,
        endY: player.y,
        progress: 0,
        pulling: false,
        target: player
    };
    
    // 0.25秒後開始拉回玩家
    setTimeout(() => {
        if (licker.tongue) {
            licker.tongue.pulling = true;
            
            // 拉回玩家後造成傷害
            setTimeout(() => {
                player.alive = false;
                
                if (player.isCompanion) {
                    showStatusMessage('你的同伴被舔食者殺死了!', 'error');
                }
                
                // 總是檢查玩家切換，現在這個函數會處理同伴轉換的情況
                checkPlayerSwitch();
                licker.tongue = null;
            }, 220);
        }
    }, 220);
}


function handleZombiePlayerInteractions() {
    const player = players[currentPlayerIndex];
    if (!player || !player.alive) return;
    
    enemies.forEach(zombie => {
        if (zombie.type === 'zombie') {
            checkZombiePlayerCollision(zombie, player);
        }
    });
}

function updateGame() {
    if (gameState !== 'playing') return;
        
    try {
        console.log("--- 遊戲更新 ---"); // 調試
        
        // 1. 更新所有玩家的傳送冷卻狀態
        players.forEach(player => {
            if (player.isTeleporting && Date.now() - player.lastTeleportTime >= 1500) {
                player.isTeleporting = false;
                if (players[currentPlayerIndex] === player) {
                    showStatusMessage('傳送冷卻結束，可以再次傳送', 'success');
                }
            }
        });
        
        // 2. 更新遊戲各系統
        updatePlayer(); // 更新玩家狀態（包含傳送檢查）
        updateZombieBehavior(); // 添加這行
        updateCompanionSystem(); // 新增同伴系統更新
        updateEnemies(); // 更新敵人行為
        updateBullets(); // 更新玩家子彈
        updateEnemyBullets(); // 更新敵方子彈
        updateGrenade(); // 更新手榴彈狀態
        updateWindows(); // 更新窗戶狀態
        checkReloadStatus(); // 檢查裝彈狀態
        
        // 3. 繪製遊戲畫面
        drawGrid();
        
        // 4. 檢查遊戲是否結束並繼續循環
        if (!checkGameOver()) {
            requestAnimationFrame(updateGame);
        }
    } catch (error) {
        console.error('遊戲更新錯誤:', error);
        // 錯誤發生時顯示狀態消息
        showStatusMessage(`遊戲更新錯誤: ${error.message}`, 'error');
        
        // 嘗試恢復遊戲循環
        setTimeout(() => {
            requestAnimationFrame(updateGame);
        }, 1000);
    }
}
// 更新玩家狀態
function updatePlayerState() {
    if (players.length === 0 || !players[currentPlayerIndex].alive || !players[currentPlayerIndex].canMove) return;
    
    const player = players[currentPlayerIndex];
    let vx = 0, vy = 0;
    if (keys.w) vy -= player.speed;
    if (keys.s) vy += player.speed;
    if (keys.a) vx -= player.speed;
    if (keys.d) vx += player.speed;
    
    if (vx !== 0 && vy !== 0) {
        vx *= 0.707;
        vy *= 0.707;
    }
    
    const newX = player.x + vx / cellSize;
    const newY = player.y + vy / cellSize;
    
    if (!isColliding(newX, player.y)) player.x = newX;
    if (!isColliding(player.x, newY)) player.y = newY;
    
    // 更新玩家角度（基於鼠標位置）
    updatePlayerAngle(player);
}

// 更新玩家角度
function updatePlayerAngle(player) {
    const rect = canvas.getBoundingClientRect();
    
    // 計算玩家在畫布上的屏幕位置（考慮攝像機偏移）
    const playerScreenX = (player.x - cameraOffset.x) * cellSize;
    const playerScreenY = (player.y - cameraOffset.y) * cellSize;
    
    // 計算鼠標相對於玩家位置的向量
    const dx = mouseX - playerScreenX;
    const dy = mouseY - playerScreenY;
    
    // 計算角度 (弧度)
    player.angle = Math.atan2(dy, dx);
    
    console.log(`玩家角度更新: ${player.angle} radians (${player.angle * 180/Math.PI}°)`);
}


// 更新敵人狀態
function updateEnemies() {
    enemies.forEach(enemy => {
        if (enemy.type === 'zombie') {
            // 喪屍專用邏輯
            if (enemy.detectedPlayer) {
                moveZombieToPlayer(enemy);
            } else {
                moveZombie(enemy);
            }
        } 
        else if (enemy.type === ENEMY_TYPES.LICKER) {
            updateLickerBehavior(enemy);
        }else {
            // 普通敵人專用邏輯
            moveEnemy(enemy);  // 包含7格停止邏輯
            enemyShoot(enemy); // 射擊邏輯
        }
        
        applyGlobalSeparation(enemy);
    });
    resolveZombieCollisions();
}


function updateLickerBehavior(licker) {
    // 冷卻處理
    if (licker.tongueCooldown > 0) {
        licker.tongueCooldown--;
    }

    // 使用新定義的函數尋找目標
    const targetPlayer = findNearestPlayerInRange(licker, 5); // 5格範圍
    
    // 檢查目標玩家是否正在移動（非靜步狀態）
    const isTargetMoving = targetPlayer && 
                         (!targetPlayer.isSlowWalking || 
                          targetPlayer.isSprinting);
    
    if (targetPlayer && !licker.tongue && isTargetMoving) {
        // 設置為追逐狀態
        licker.movementState = LICKER_MOVEMENT.CHASING;
        
        // 開始舌頭攻擊
        licker.tongue = {
            target: targetPlayer,
            progress: 0,
            pulling: false,
            startX: licker.x,
            startY: licker.y,
            damage: 25 // 每次攻擊造成的傷害
        };
        
        // 標記玩家被抓住（禁用控制）
        targetPlayer.isStunned = true;
    } else if (!licker.tongue) {
        // 沒有攻擊目標時，執行隨機移動
        updateLickerMovement(licker);
    }

    // 更新舌頭動畫
    if (licker.tongue) {
        updateTongueAttack(licker);
    }
}

// 新增 Licker 移動邏輯
function updateLickerMovement(licker) {
    // 初始化移動狀態
    if (licker.movementState === undefined) {
        licker.movementState = LICKER_MOVEMENT.IDLE;
        licker.idleTimer = 0;
        licker.wanderTimer = 0;
        licker.targetX = licker.x;
        licker.targetY = licker.y;
    }

    // 根據當前狀態執行不同行為
    switch (licker.movementState) {
        case LICKER_MOVEMENT.IDLE:
            // 閒置狀態
            licker.idleTimer++;
            
            // 閒置一段時間後轉為遊蕩
            if (licker.idleTimer > 60 + Math.random() * 120) { // 1-3秒
                licker.movementState = LICKER_MOVEMENT.WANDERING;
                licker.wanderTimer = 0;
                
                // 隨機選擇一個方向
                const angle = Math.random() * Math.PI * 2;
                const distance = 2 + Math.random() * 3; // 2-5格距離
                
                licker.targetX = licker.x + Math.cos(angle) * distance;
                licker.targetY = licker.y + Math.sin(angle) * distance;
                
                // 確保目標位置在地圖範圍內且不是牆壁
                licker.targetX = Math.max(0, Math.min(gridSize - 1, licker.targetX));
                licker.targetY = Math.max(0, Math.min(gridSize - 1, licker.targetY));
                
                // 檢查目標位置是否可通行
                const targetGridX = Math.floor(licker.targetX);
                const targetGridY = Math.floor(licker.targetY);
                if (grid[targetGridY][targetGridX] === 'wall') {
                    // 如果是牆壁，重新選擇方向
                    licker.movementState = LICKER_MOVEMENT.IDLE;
                    licker.idleTimer = 0;
                }
            }
            break;
            
        case LICKER_MOVEMENT.WANDERING:
            // 遊蕩狀態
            licker.wanderTimer++;
            
            // 計算到目標點的距離
            const dx = licker.targetX - licker.x;
            const dy = licker.targetY - licker.y;
            const distToTarget = Math.sqrt(dx * dx + dy * dy);
            
            if (distToTarget < 0.1 || licker.wanderTimer > 180) { // 到達目標或超過3秒
                // 轉為閒置狀態
                licker.movementState = LICKER_MOVEMENT.IDLE;
                licker.idleTimer = 0;
            } else {
                // 向目標點移動
                const speed = 0.03; // 移動速度
                const newX = licker.x + (dx / distToTarget) * speed;
                const newY = licker.y + (dy / distToTarget) * speed;
                
                // 檢查新位置是否可通行
                const newGridX = Math.floor(newX);
                const newGridY = Math.floor(newY);
                const oldGridX = Math.floor(licker.x);
                const oldGridY = Math.floor(licker.y);
                
                if (grid[newGridY][newGridX] !== 'wall' || 
                    (newGridX === oldGridX && newGridY === oldGridY)) {
                    // 如果新位置不是牆壁，或者仍在同一格子內，則移動
                    licker.x = newX;
                    licker.y = newY;
                } else {
                    // 如果碰到牆壁，轉為閒置狀態
                    licker.movementState = LICKER_MOVEMENT.IDLE;
                    licker.idleTimer = 0;
                }
            }
            break;
            
        case LICKER_MOVEMENT.CHASING:
            // 追逐狀態（由攻擊邏輯處理）
            break;
    }
}

// 在 createEnemy 函數中添加 Licker 的初始化（如果有的話）
function createEnemy(type, x, y) {
    const enemy = {
        type: type,
        x: x,
        y: y,
        health: 100,
        speed: 0.02,
        // 其他共用屬性...
    };
    
    // Licker 專用屬性
    if (type === ENEMY_TYPES.LICKER) {
        enemy.tongueCooldown = 0;
        enemy.movementState = LICKER_MOVEMENT.IDLE;
        enemy.idleTimer = 0;
        enemy.wanderTimer = 0;
        enemy.targetX = x;
        enemy.targetY = y;
    }
    
    return enemy;
}

function findNearestPlayerInRange(enemy, range) {
    let nearestPlayer = null;
    let minDistance = Infinity;

    players.forEach(player => {
        // 只檢查存活的玩家
        if (!player.alive) return;

        const dist = distance(enemy.x, enemy.y, player.x, player.y);
        
        // 檢查是否在範圍內且有視線
        if (dist <= range && 
            hasLineOfSight(enemy.x, enemy.y, player.x, player.y)) {
            if (dist < minDistance) {
                minDistance = dist;
                nearestPlayer = player;
            }
        }
    });

    return nearestPlayer;
}
function updateTongueAttack(licker) {
    const tongue = licker.tongue;
    tongue.progress += 0.1; // 快速動畫

    // 舌頭伸出階段
    if (!tongue.pulling && tongue.progress >= 1) {
        tongue.pulling = true;
        tongue.progress = 0;
    }

    // 舌頭拉回階段
    if (tongue.pulling) {
        if (tongue.progress >= 1) {
            tongue.target.alive = false;
            
            if (tongue.target.isCompanion) {
                showStatusMessage('你的同伴被舔食者殺死了!', 'error');
            }
            
            // 總是檢查玩家切換
            checkPlayerSwitch();
            licker.tongue = null;
            licker.tongueCooldown = 120;
        } else {
            // 正在拉回玩家
            tongue.target.x = lerp(tongue.target.x, licker.x, tongue.progress);
            tongue.target.y = lerp(tongue.target.y, licker.y, tongue.progress);
        }
    }
}




// 線性插值函數
function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}



function updateEnemyPathList() {
  const list = document.getElementById('enemyPathList');
  list.innerHTML = '';
  
  enemies.forEach((enemy, index) => {
    const item = document.createElement('li');
    item.textContent = `敵人 ${index+1}: ${enemy.path?.length || 0} 路徑點`;
    item.style.color = enemy === currentPathEnemy ? '#FF0' : '#FFF';
    item.onclick = () => selectEnemyForEdit(index);
    list.appendChild(item);
  });
}


function selectEnemyForEdit(index) {
  currentPathEnemy = enemies[index];
  enemyPathPoints = currentPathEnemy.path ? [...currentPathEnemy.path] : [];
  drawGrid();
}


function attackPlayersAndCompanions(zombie) {
    // 檢查所有玩家和同伴
    players.forEach(player => {
        if (player.alive) {
            const dist = Math.sqrt((zombie.x - player.x) ** 2 + (zombie.y - player.y) ** 2);
            
            // 如果距離足夠近，造成傷害
            if (dist < 0.5) {
                player.health -= 1;
                
                // 隨機有機率吃掉同伴
                if (player.isCompanion && Math.random() < 0.01) {
                    player.alive = false;
                    showStatusMessage('你的同伴被喪屍吃掉了!', 'error');
                }
                
                if (player.health <= 0) {
                    player.alive = false;
                    if (player.isCompanion) {
                        showStatusMessage('你的同伴已死亡!', 'error');
                    }
                }
            }
        }
    });
}



// 新增輔助函數檢查玩家是否在附近
function isPlayerNearby(enemy) {
    for (const player of players) {
        if (player.alive) {
            const dist = Math.sqrt(
                Math.pow(enemy.x - player.x, 2) + 
                Math.pow(enemy.y - player.y, 2)
            );
            if (dist <= 25 && hasLineOfSight(enemy.x, enemy.y, player.x, player.y)) {
                return true;
            }
        }
    }
    return false;
}

// 更新子彈狀態
function updateBullets() {
    bullets = bullets.filter(bullet => {
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        bullet.distanceTraveled += Math.sqrt(bullet.dx * bullet.dx + bullet.dy * bullet.dy);
        
        // 檢查子彈是否超出範圍或擊中牆壁
        const gridX = Math.floor(bullet.x);
        const gridY = Math.floor(bullet.y);
        if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize || 
            isColliding(bullet.x, bullet.y, false, true)) { // 注意這裡傳入isBullet=true
            return false;
        }
        
        // 檢查子彈是否擊中敵人
        let hitEnemy = false;
        enemies = enemies.filter(enemy => {
            const dist = Math.sqrt((enemy.x - bullet.x) ** 2 + (enemy.y - bullet.y) ** 2);
            if (dist < 0.5) {
                bullet.enemiesHit++;
                if (bullet.enemiesHit >= bullet.penetration) {
                    hitEnemy = true;
                }
                return false;
            }
            return true;
        });
        
        return !hitEnemy && bullet.distanceTraveled <= bullet.range;
    });
}

// 更新敵人子彈狀態
function updateEnemyBullets() {
    enemyBullets = enemyBullets.filter(bullet => {
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        const x = Math.floor(bullet.x);
        const y = Math.floor(bullet.y);
        if (x < 0 || x >= gridSize || y < 0 || y >= gridSize || grid[y][x] === 'wall') return false;
        return true;
    });
}

// 更新手榴彈狀態
function updateGrenade() {
    if (grenade && grenade.thrown) {
        if (grenade.progress < 1) {
            grenade.progress += 0.1;
            grenade.x = players[currentPlayerIndex].x + (grenade.targetX - players[currentPlayerIndex].x) * grenade.progress;
            grenade.y = players[currentPlayerIndex].y + (grenade.targetY - players[currentPlayerIndex].y) * grenade.progress;
        }
        if (grenade.progress >= 1) {
            handleGrenadeExplosion();
        }
    }
}

// 處理手榴彈爆炸
function handleGrenadeExplosion() {
    const grenadeX = grenade.x;
    const grenadeY = grenade.y;
    if (isNaN(grenadeX) || isNaN(grenadeY) || 
        grenadeX < 0 || grenadeX >= gridSize || 
        grenadeY < 0 || grenadeY >= gridSize) {
        console.log('Invalid grenade position, cancelling explosion');
        grenade = null;
        return;
    }
    
    const explosionRadius = bulletSettings.grenadeExplosionRadius;
    console.log(`Grenade exploded at (${grenadeX.toFixed(2)}, ${grenadeY.toFixed(2)}). Enemies before: ${enemies.length}`);
    
    enemies = enemies.filter(enemy => {
        const dist = Math.sqrt((enemy.x - grenadeX) ** 2 + (enemy.y - grenadeY) ** 2);
        const keep = dist > explosionRadius;
        if (!keep) {
            console.log(`Removing enemy at (${enemy.x.toFixed(2)}, ${enemy.y.toFixed(2)}) with distance ${dist.toFixed(2)}`);
        }
        return keep;
    });
    
    console.log(`Enemies after grenade: ${enemies.length}`);
    grenade = null;
    players[currentPlayerIndex].grenadeCount--;
    updateAmmoDisplay();
}

// 檢查裝彈狀態
function checkReloadStatus() {
    const player = players[currentPlayerIndex];
    if (player.isReloading) {
        const weaponType = player.weaponMode === 1 ? 'pistol' : 
                          player.weaponMode === 2 ? 'auto' : 'shotgun';
        
        const currentTime = performance.now();
        const elapsed = (currentTime - player.reloadStartTime) / 1000;
        const remainingTime = (player.reloadTime[weaponType] - elapsed).toFixed(1);
        
        console.log(`裝彈中... 已過: ${elapsed.toFixed(2)}秒，剩余: ${remainingTime}秒`);
        
        if (remainingTime > 0) {
            statusMessage.textContent = `上彈中... ${remainingTime}秒`;
        }
        
        if (elapsed >= player.reloadTime[weaponType]) {
            const magazineSize = player.magazineSize[weaponType];
            const ammoNeeded = magazineSize - player.ammo;
            const ammoToAdd = Math.min(ammoNeeded, player.totalAmmo);
            
            player.ammo += ammoToAdd;
            player.totalAmmo -= ammoToAdd;
            player.isReloading = false;
            player.canMove = true;
            player.canShoot = true;
            
            showStatusMessage('上彈完成！', 'success');
            updateAmmoDisplay();
            
            console.log(`裝彈完成！補充彈藥: ${ammoToAdd}，當前彈藥: ${player.ammo}/${player.totalAmmo}`);
        }
    }
}


function saveMap() {
    try {
        const saveData = prepareSaveData();
        persistSaveData(saveData);
        showSaveSuccess(saveData);
    } catch (error) {
        handleSaveError(error);
    }
}

// 準備保存數據
function prepareSaveData() {
    return {
        teleports: prepareTeleportsData(),
        currentTeleportColor: currentTeleportColor,
        placingTeleportA: placingTeleportA,
        currentTeleportPairId: currentTeleportPairId,
        gridSize: gridSize,
        grid: grid,
        players: preparePlayersData(),
        enemies: enemies,
        windows: prepareWindowsData(),
        defenseAreas: defenseAreas,ammoDepots: ammoDepots.map(depot => ({
            x: depot.x,
            y: depot.y,
            collected: depot.collected
        })),
        weaponSettings: prepareWeaponSettings()
    };
}

// 準備傳送點數據
function prepareTeleportsData() {
    return teleports.map(tp => ({
        x: tp.x,
        y: tp.y,
        color: tp.color,
        pairId: tp.pairId,
        isA: tp.isA
    }));
}

// 準備玩家數據
function preparePlayersData() {
    return players.map(player => ({
        x: player.x,
        y: player.y,
        placed: player.placed,
        ammo: player.ammo,
        magazineSize: player.magazineSize,
        totalAmmo: player.totalAmmo,
        grenadeCount: player.grenadeCount,
        health: player.health,
        alive: player.alive
    }));
}

// 準備窗戶數據
function prepareWindowsData() {
    return windows.map(win => ({
        x: win.x,
        y: win.y,
        health: win.health,
        lastHitTime: win.lastHitTime,
        bulletHits: win.bulletHits
    }));
}

// 準備武器設置
function prepareWeaponSettings() {
    return {
        magazineSize: getInputValue('magazineSize', 'int', 10),
        totalAmmo: getInputValue('totalAmmo', 'int', 50),
        grenadeCount: getInputValue('grenadeCount', 'int', 3),
        grenadeRange: getInputValue('grenadeRange', 'float', 10),
        grenadeExplosionRadius: getInputValue('grenadeExplosionRadius', 'float', 2)
    };
}

// 通用輸入值獲取函數
function getInputValue(elementId, type, defaultValue) {
    const value = document.getElementById(elementId).value;
    if (type === 'int') return parseInt(value) || defaultValue;
    if (type === 'float') return parseFloat(value) || defaultValue;
    return value || defaultValue;
}

// 持久化保存數據
function persistSaveData(saveData) {
    localStorage.setItem('mazeGameSaveData', JSON.stringify(saveData));
}

// 顯示保存成功
function showSaveSuccess(saveData) {
    showStatusMessage('地圖保存成功！', 'success');
    console.log('地圖已保存:', saveData);
}

// 處理保存錯誤
function handleSaveError(error) {
    console.error('保存地圖錯誤:', error);
    showStatusMessage('保存地圖失敗！', 'error');
}

function loadMap() {
    try {
        const saveData = getSavedData();
        if (!saveData) return;
        
        const parsedData = parseSavedData(saveData);
        loadBasicMapData(parsedData);
        loadPlayersData(parsedData);
        loadEnemiesData(parsedData);
        loadDefenseAreas(parsedData);
        loadWindowsData(parsedData);
        loadTeleportsData(parsedData);
        loadWeaponSettings(parsedData);
        loadGameState(parsedData);
        resetEnemyPathSettings();
        
        finalizeMapLoading();
        
        showStatusMessage('地圖加載成功！', 'success');
        console.log('地圖已加載:', parsedData);
    } catch (error) {
        handleLoadError(error);
    }
}

// Helper functions
function getSavedData() {
    const saveData = localStorage.getItem('mazeGameSaveData');
    if (!saveData) {
        showStatusMessage('沒有找到保存的地圖！', 'error');
        return null;
    }
    return saveData;
}

function parseSavedData(saveData) {
    return JSON.parse(saveData);
}

function loadBasicMapData(parsedData) {
    gridSize = parsedData.gridSize;
    gridSizeInput.value = gridSize;
    grid = parsedData.grid;
}

function loadPlayersData(parsedData) {
    players = parsedData.players.map(playerData => ({
        ...playerData,
        vx: 0,
        vy: 0,
        speed: 2/3,
        weaponMode: 1,
        lastShotTime: 0,
        shootRate: 200,
        grenadeCount: playerData.grenadeCount || 3
    }));
}

function loadEnemiesData(parsedData) {
    enemies = parsedData.enemies;
}

function loadDefenseAreas(parsedData) {
    defenseAreas = parsedData.defenseAreas || [];
}

function loadWindowsData(parsedData) {
    if (parsedData.windows) {
        windows = parsedData.windows.map(w => {
            const win = createWindow(w.x, w.y);
            win.health = w.health || 100;
            win.lastHitTime = w.lastHitTime || 0;
            win.bulletHits = w.bulletHits || 0;
            return win;
        });
    } else {
        windows = [];
    }
}

function loadTeleportsData(parsedData) {
    if (parsedData.teleports) {
        teleports = parsedData.teleports;
        currentTeleportColor = parsedData.currentTeleportColor || getRandomFluorescentColor();
        placingTeleportA = parsedData.placingTeleportA !== undefined ? parsedData.placingTeleportA : true;
        currentTeleportPairId = parsedData.currentTeleportPairId || 0;
    } else {
        teleports = [];
        currentTeleportColor = getRandomFluorescentColor();
        placingTeleportA = true;
        currentTeleportPairId = 0;
    }
}

// 修改 loadWeaponSettings 函數
function loadWeaponSettings(parsedData) {
    magazineSizeInput.value = parsedData.magazineSize;
    totalAmmoInput.value = parsedData.totalAmmo;
    document.getElementById('grenadeCount').value = parsedData.grenadeCount || 3;
    document.getElementById('grenadeRange').value = parsedData.grenadeRange || 10;
    document.getElementById('grenadeExplosionRadius').value = parsedData.grenadeExplosionRadius || 2;
    weaponSpeedMultiplierInput.value = parsedData.weaponSpeedMultiplier || 0.1;
    
    bulletSettings.grenadeRange = parsedData.grenadeRange || 10;
    bulletSettings.grenadeExplosionRadius = parsedData.grenadeExplosionRadius || 2;
    globalWeaponSpeedMultiplier = parseFloat(weaponSpeedMultiplierInput.value) || 0.5;
}

function loadGameState(parsedData) {
    currentPlayerIndex = parsedData.currentPlayerIndex || 0;
}

function resetEnemyPathSettings() {
    settingEnemyPath = false;
    enemyPathPoints = [];
    currentPathEnemy = null;
    setEnemyPathBtn.textContent = '設置敵人路徑';
}

function finalizeMapLoading() {
    resizeCanvas();
    drawGrid();
    updatePlayersDisplay();
}

function handleLoadError(error) {
    console.error('加載地圖錯誤:', error);
    showStatusMessage('加載地圖失敗！', 'error');
}

function exportMap() {
    try {
        const saveData = {
            gridSize: gridSize,
            grid: grid,
            players: players.map(player => ({
                x: player.x,
                y: player.y,
                placed: player.placed,
                ammo: player.ammo,
                magazineSize: player.magazineSize,
                totalAmmo: player.totalAmmo,
                grenadeCount: player.grenadeCount,
                health: player.health,
                alive: player.alive
            })),
            enemies: enemies,
            defenseAreas: defenseAreas,
            // 新增窗戶數據
            windows: windows.map(win => ({
                x: win.x,
                y: win.y,
                health: win.health,
                lastHitTime: win.lastHitTime,
                bulletHits: win.bulletHits
            })),
            // 新增傳送點數據
            teleports: teleports.map(tp => ({
                x: tp.x,
                y: tp.y,
                color: tp.color,
                pairId: tp.pairId,
                isA: tp.isA
            })),
            ammoDepots: ammoDepots.map(depot => ({
                x: depot.x,
                y: depot.y,
                collected: depot.collected
            })),
            currentTeleportColor: currentTeleportColor,
            placingTeleportA: placingTeleportA,
            currentTeleportPairId: currentTeleportPairId,
            magazineSize: parseInt(magazineSizeInput.value),
            totalAmmo: parseInt(totalAmmoInput.value),
            grenadeCount: parseInt(document.getElementById('grenadeCount').value) || 3,
            grenadeRange: parseFloat(document.getElementById('grenadeRange').value) || 10,
            grenadeExplosionRadius: parseFloat(document.getElementById('grenadeExplosionRadius').value) || 2,
            weaponSpeedMultiplier: parseFloat(weaponSpeedMultiplierInput.value) || 0.5
        };
        
        jsonDataTextarea.value = JSON.stringify(saveData, null, 2);
        showStatusMessage('地圖已導出到文本框!', 'success');
    } catch (error) {
        console.error('導出地圖錯誤:', error);
        showStatusMessage('導出地圖失敗！', 'error');
    }
}


// 添加事件監聽器，當輸入值改變時更新全局變量
weaponSpeedMultiplierInput.addEventListener('change', function() {
    globalWeaponSpeedMultiplier = parseFloat(this.value) || 0.5;
});
function importMap() {
    try {
        const json = getJsonInput();
        if (!json) return;
        
        const parsedData = parseJsonData(json);
        importBasicMapData(parsedData);
        importPlayersData(parsedData);
        importEnemiesData(parsedData);
        importDefenseAreas(parsedData);
        importWindowsData(parsedData);
        importTeleportsData(parsedData);
        importWeaponSettings(parsedData);
        importGameState(parsedData);
        resetEnemyPathSettings();
        
        if (parsedData.ammoDepots) {
            ammoDepots = parsedData.ammoDepots.map(d => ({
                x: d.x,
                y: d.y,
                collected: d.collected || false
            }));
        } else {
            ammoDepots = [];
            //handleImportError(error);
        }


        resizeCanvas();
        drawGrid();
        updatePlayersDisplay();
        
        showStatusMessage('地圖導入成功！', 'success');
    } catch (error) {
        //handleImportError(error);
    }
}

// Helper functions
function getJsonInput() {
    const json = jsonDataTextarea.value.trim();
    if (!json) {
        showStatusMessage('請先粘貼JSON數據!', 'error');
        return null;
    }
    return json;
}

function parseJsonData(json) {
    return JSON.parse(json);
}

function importBasicMapData(parsedData) {
    gridSize = parsedData.gridSize;
    gridSizeInput.value = gridSize;
    grid = parsedData.grid;
}

function importPlayersData(parsedData) {
    players = parsedData.players.map(playerData => ({
        ...playerData,
        vx: 0,
        vy: 0,
        speed: 2/3,
        weaponMode: 1,
        lastShotTime: 0,
        shootRate: 200,
        grenadeCount: playerData.grenadeCount || 3
    }));
}

function importEnemiesData(parsedData) {
    enemies = parsedData.enemies;
}

function importDefenseAreas(parsedData) {
    defenseAreas = parsedData.defenseAreas || [];
}

function importWindowsData(parsedData) {
    if (parsedData.windows) {
        windows = parsedData.windows.map(w => {
            const win = createWindow(w.x, w.y);
            win.health = w.health || 100;
            win.lastHitTime = w.lastHitTime || 0;
            win.bulletHits = w.bulletHits || 0;
            return win;
        });
    } else {
        windows = [];
    }
}

function importTeleportsData(parsedData) {
    if (parsedData.teleports) {
        teleports = parsedData.teleports;
        currentTeleportColor = parsedData.currentTeleportColor || getRandomFluorescentColor();
        placingTeleportA = parsedData.placingTeleportA !== undefined ? parsedData.placingTeleportA : true;
        currentTeleportPairId = parsedData.currentTeleportPairId || 0;
    } else {
        teleports = [];
        currentTeleportColor = getRandomFluorescentColor();
        placingTeleportA = true;
        currentTeleportPairId = 0;
    }
}

function importWeaponSettings(parsedData) {
    magazineSizeInput.value = parsedData.magazineSize;
    totalAmmoInput.value = parsedData.totalAmmo;
    document.getElementById('grenadeCount').value = parsedData.grenadeCount || 3;
    document.getElementById('grenadeRange').value = parsedData.grenadeRange || 10;
    document.getElementById('grenadeExplosionRadius').value = parsedData.grenadeExplosionRadius || 2;
    weaponSpeedMultiplierInput.value = parsedData.weaponSpeedMultiplier || 0.1;
    
    bulletSettings.grenadeRange = parsedData.grenadeRange || 10;
    bulletSettings.grenadeExplosionRadius = parsedData.grenadeExplosionRadius || 2;
    globalWeaponSpeedMultiplier = parseFloat(weaponSpeedMultiplierInput.value) || 0.5;
}


function importGameState(parsedData) {
    currentPlayerIndex = parsedData.currentPlayerIndex || 0;
}

function resetEnemyPathSettings() {
    settingEnemyPath = false;
    enemyPathPoints = [];
    currentPathEnemy = null;
    setEnemyPathBtn.textContent = '設置敵人路徑';
}

function handleImportError(error) {
    console.error('導入地圖錯誤:', error);
    showStatusMessage('導入地圖失敗 - 無效的JSON!', 'error');
}

function showStatusMessage(message, type) {
    statusMessage.textContent = message;
    statusMessage.className = 'status-message';
    if (type === 'success') {
        statusMessage.classList.add('success-message');
    } else if (type === 'error') {
        statusMessage.classList.add('error-message');
    } else {
        statusMessage.classList.add('info-message');
    }
    
    setTimeout(() => {
        statusMessage.textContent = '';
        statusMessage.className = 'status-message';
    }, 3000);
}

function restartGame() {
    // 隱藏遊戲結束畫面
    gameOverScreen.classList.add('hidden');
    
    // 重置為編輯模式
    gameState = 'setup';
    isEditMode = true;
    
    // 顯示設置控制面板
    setupControls.style.display = 'block';
    weaponInfo.style.display = 'none';
    playerInfo.style.display = 'none';
    
    // 從保存的狀態完全恢復
    if (savedGrid) {
        grid = savedGrid.map(row => [...row]);
    }
    if (savedEnemies) {
        enemies = JSON.parse(JSON.stringify(savedEnemies));
    }
    if (savedDefenseAreas) {
        defenseAreas = JSON.parse(JSON.stringify(savedDefenseAreas));
    }
    if (savedPlayers) {  // 恢復玩家狀態
        players = JSON.parse(JSON.stringify(savedPlayers));
    }
    
    // 重置其他遊戲元素
    bullets = [];
    enemyBullets = [];
    grenade = null;
    console.log("當前所有傳送點:", teleports);
    // 重新繪製
    resizeCanvas();
    drawGrid();
    
    showStatusMessage('已重置遊戲並返回編輯模式', 'success');
}
// 重置武器设置
// 修改 resetWeaponSettings 函數
function resetWeaponSettings() {
    document.getElementById('pistolMagazineSize').value = 10;
    document.getElementById('pistolReloadTime').value = 1;
    document.getElementById('autoMagazineSize').value = 30;
    document.getElementById('autoReloadTime').value = 2;
    document.getElementById('shotgunMagazineSize').value = 6;
    document.getElementById('shotgunReloadTime').value = 1.5;
    document.getElementById('magazineSize').value = 10;
    document.getElementById('totalAmmo').value = 50;
    document.getElementById('grenadeCount').value = 3;
    weaponSpeedMultiplierInput.value = 0.1;
    
    bulletSettings = {
        pistol: { range: 40, penetration: 1, speed: 2.5, magazineSize: 15, reloadTime: 1.5 },
        auto: { range: 12, penetration: 1, speed: 2.5, magazineSize: 30, reloadTime: 2 },
        shotgun: { range: 8, penetration: 2, speed: 1.5, magazineSize: 6, reloadTime: 1.5 },
        grenadeRange: 10,
        grenadeExplosionRadius: 2
    };
    globalWeaponSpeedMultiplier = 0.1;
}


// 带确认的重置
function confirmRestart() {
    if (confirm('確定要完全重置遊戲嗎？所有進度將丟失！')) {
        restartGame();
    }
}


// 初始化圖片加載器（原始代碼，未修改）
function initImageLoader() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/png';
    fileInput.id = 'imageLoader';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);



    fileInput.addEventListener('change', (event) => {
        if (gameState !== 'setup') return;
        const file = event.target.files[0];
        if (file && file.type === 'image/png') {
            const img = new Image();
            img.onload = () => {
                backgroundImage.img = img;
                backgroundImage.width = img.width / cellSize;
                backgroundImage.height = img.height / cellSize;
                backgroundImage.x = 0;
                backgroundImage.y = 0;
                backgroundImage.isLocked = false;
                drawGrid();
            };
            img.src = URL.createObjectURL(file);
        }
    });
}

// Trigger image loading
function loadBackgroundImage() {
    if (gameState === 'setup') {
        document.getElementById('imageLoader').click();
    }
}

// Confirm and lock image position
function confirmBackgroundImage() {
    if (gameState === 'setup' && backgroundImage.img && !backgroundImage.isLocked) {
        // Snap to nearest grid cell
        backgroundImage.x = Math.round(backgroundImage.x);
        backgroundImage.y = Math.round(backgroundImage.y);
        backgroundImage.width = Math.round(backgroundImage.width);
        backgroundImage.height = Math.round(backgroundImage.height);
        backgroundImage.isLocked = true;
        drawGrid();
    }
}

// 初始化子彈設置的用戶界面

function initBulletSettingsUI() {
    const setupControls = document.getElementById('setupControls');
    if (!setupControls) {
        console.error('未找到 setupControls 元素');
        showStatusMessage('初始化子彈設置失敗：未找到設置控制區域', 'error');
        return;
    }

    // 預設武器參數
const weaponPresets = {
pistol: {
    default: { range: 40, penetration: 1, speed: 2.5, magazineSize: 15, reloadTime: 1.5 },
    glock17: { range: 35, penetration: 1, speed: 3.125, magazineSize: 17, reloadTime: 1.2 }, // 奧地利，美國海豹部隊
    desertEagle: { range: 45, penetration: 2, speed: 2.25, magazineSize: 7, reloadTime: 1.8 }, // 以色列，少數特種用途
    fn57: { range: 50, penetration: 3, speed: 2.75, magazineSize: 20, reloadTime: 1.5 }, // 比利時，美國特種部隊
    beretta92: { range: 38, penetration: 1, speed: 2.875, magazineSize: 15, reloadTime: 1.4 }, // 義大利，美國陸軍
    sigSauerP226: { range: 40, penetration: 2, speed: 2.625, magazineSize: 15, reloadTime: 1.3 }, // 德國/瑞士，英國SAS
    cz75: { range: 37, penetration: 1, speed: 2.75, magazineSize: 16, reloadTime: 1.5 }, // 捷克，東歐特種部隊
    usp45: { range: 42, penetration: 2, speed: 2.5, magazineSize: 12, reloadTime: 1.6 }, // 德國，德國GSG9
    makarov: { range: 35, penetration: 1, speed: 2.875, magazineSize: 8, reloadTime: 1.2 }, // 俄羅斯，俄羅斯Spetsnaz
    waltherPPK: { range: 30, penetration: 1, speed: 3.25, magazineSize: 7, reloadTime: 1.1 }, // 德國，情報單位
    taurusPT92: { range: 38, penetration: 1, speed: 2.625, magazineSize: 17, reloadTime: 1.4 }, // 巴西，巴西BOPE


    awm: { range: 150, penetration: 5, speed: 1.25, magazineSize: 5, reloadTime: 3 }, // 英國，英國SAS
    barrett: { range: 180, penetration: 6, speed: 1, magazineSize: 10, reloadTime: 4 }, // 美國，美國海豹部隊
    m24: { range: 140, penetration: 4, speed: 1.375, magazineSize: 5, reloadTime: 3.2 }, // 美國，美國陸軍
    svd: { range: 130, penetration: 4, speed: 1.5, magazineSize: 10, reloadTime: 2.8 }, // 俄羅斯，俄羅斯Spetsnaz
    l96a1: { range: 145, penetration: 5, speed: 1.25, magazineSize: 10, reloadTime: 3 }, // 英國，英國皇家海軍陸戰隊
    cheytacM200: { range: 200, penetration: 6, speed: 0.875, magazineSize: 7, reloadTime: 4.5 }, // 美國，特種狙擊用途
    rem700: { range: 135, penetration: 4, speed: 1.375, magazineSize: 5, reloadTime: 3.1 }, // 美國，美國海軍陸戰隊
    sr25: { range: 120, penetration: 3, speed: 1.625, magazineSize: 20, reloadTime: 2.5 }, // 美國，美國特種部隊
    m40a5: { range: 140, penetration: 5, speed: 1.25, magazineSize: 5, reloadTime: 3.3 }, // 美國，美國海軍陸戰隊
    tac50: { range: 190, penetration: 6, speed: 0.875, magazineSize: 5, reloadTime: 4.2 }, // 加拿大，加拿大JTF2


},


    auto: {
        // 衝鋒槍
    default: { range: 12, penetration: 7, speed: 2.5, magazineSize:25 ,reloadTime: 2 },
    mp5: { range: 15, penetration: 2.75, speed: 2.75, magazineSize: 30, reloadTime: 2.2 }, // 德國，德國GSG9、美國海豹部隊
    p90: { range: 20, penetration: 3, speed: 3.125, magazineSize: 50, reloadTime: 2.5 }, // 比利時，加拿大JTF2
    ump45: { range: 18, penetration: 2, speed: 2.625, magazineSize: 25, reloadTime: 2.3 }, // 德國，美國SWAT
    mac10: { range: 10, penetration: 1, speed: 3.5, magazineSize: 30, reloadTime: 1.1 }, // 美國，特種快速反應
    pp2000: { range: 14, penetration: 2, speed: 2.875, magazineSize: 20, reloadTime: 2 }, // 俄羅斯，俄羅斯FSB
    mp7: { range: 17, penetration: 3, speed: 3, magazineSize: 40, reloadTime: 2.4 }, // 德國，德國KSK
    skorpion: { range: 12, penetration: 1, speed: 3.25, magazineSize: 20, reloadTime: 1.8 }, // 捷克，東歐特種部隊
    uzi: { range: 13, penetration: 1, speed: 3.125, magazineSize: 32, reloadTime: 2 }, // 以色列，以色列特種部隊
    krissVector: { range: 16, penetration: 2, speed: 3.375, magazineSize: 30, reloadTime: 2.1 }, // 美國，泰國特種部隊
    mp9: { range: 15, penetration: 2, speed: 3.1, magazineSize: 30, reloadTime: 2.2 }, // 瑞士，瑞士特警
//突擊步槍

        m4: { range: 50, penetration: 2, speed: 2.25, magazineSize: 30, reloadTime: 2.5 }, // 美國，美國海豹部隊
    ak47: { range: 45, penetration: 3, speed: 1.875, magazineSize: 30, reloadTime: 3 }, // 俄羅斯，俄羅斯Spetsnaz
    scarH: { range: 55, penetration: 3, speed: 2, magazineSize: 20, reloadTime: 2.7 }, // 比利時，美國SOCOM
    g36: { range: 50, penetration: 2, speed: 2.25, magazineSize: 30, reloadTime: 2.4 }, // 德國，德國KSK
    augA3: { range: 48, penetration: 2, speed: 2.375, magazineSize: 30, reloadTime: 2.3 }, // 奧地利，奧地利特種部隊
    tar21: { range: 45, penetration: 2, speed: 2.5, magazineSize: 30, reloadTime: 2.2 }, // 以色列，以色列特種部隊
    famas: { range: 40, penetration: 2, speed: 2.625, magazineSize: 25, reloadTime: 2.1 }, // 法國，法國GIGN
    l85a2: { range: 50, penetration: 2, speed: 2.125, magazineSize: 30, reloadTime: 2.6 }, // 英國，英國SAS
    qbz95: { range: 45, penetration: 2, speed: 2.25, magazineSize: 30, reloadTime: 2.5 }, // 中國，中國特種部隊
    hk416: { range: 52, penetration: 2, speed: 2.375, magazineSize: 30, reloadTime: 2.3 } // 德國，美國Delta Force

    },


    shotgun: {
        // 軍用散彈槍
    default: { range: 8, penetration: 2, speed: 1.5, magazineSize: 8, reloadTime: 2 },
    m870: { range: 10, penetration: 3, speed: 1.25, magazineSize: 7, reloadTime: 2.5 }, // 美國，美國海豹部隊
    aa12: { range: 12, penetration: 2, speed: 1.875, magazineSize: 20, reloadTime: 2 }, // 美國，特種突擊用途
    saiga12: { range: 9, penetration: 3, speed: 1.75, magazineSize: 10, reloadTime: 2.2 }, // 俄羅斯，俄羅斯FSB
    spas12: { range: 11, penetration: 4, speed: 1.625, magazineSize: 8, reloadTime: 2.3 }, // 義大利，義大利特種部隊
    benelliM4: { range: 10, penetration: 3, speed: 2, magazineSize: 7, reloadTime: 2 }, // 義大利，美國海軍
    mossberg590: { range: 9, penetration: 3, speed: 1.5, magazineSize: 6, reloadTime: 2.4 }, // 美國，美國SWAT
    ksg: { range: 10, penetration: 2, speed: 1.875, magazineSize: 14, reloadTime: 2.2 }, // 美國，特種用途
    m26: { range: 8, penetration: 2, speed: 2.125, magazineSize: 5, reloadTime: 2.1 }, // 美國，M4附掛式散彈槍
    fabarm: { range: 11, penetration: 3, speed: 1.625, magazineSize: 8, reloadTime: 2.3 }, // 義大利，歐洲特警
    usas12: { range: 12, penetration: 3, speed: 1.75, magazineSize: 10, reloadTime: 2.5 } // 南韓，南韓特種部隊



    },
grenade: {
    // 通用/默认
    default: { range: 20, explosionRadius: 2, country: "Generic" },
    
    // 手榴弹（各国型号）
    frag_M67: { range: 25, explosionRadius: 3, country: "USA" },       // 美国M67破片手榴弹
    frag_RGD5: { range: 20, explosionRadius: 3.5, country: "Russia" }, // 俄罗斯RGD-5
    frag_Type82: { range: 22, explosionRadius: 2.8, country: "China" },// 中国82式
    
    // 榴弹发射器（40mm）
    GL_M433: { range: 350, explosionRadius: 5, country: "USA" },       // 美国M433 HEDP
    GL_GP25: { range: 400, explosionRadius: 6, country: "Russia" },    // 俄罗斯GP-25
    GL_QLG10: { range: 380, explosionRadius: 4.5, country: "China" },  // 中国QLG10
    
    // 反坦克导弹/RPG
    RPG7_PG7VL: { range: 500, explosionRadius: 10, country: "Russia" }, // RPG-7破甲弹
    AT4_HEAT: { range: 300, explosionRadius: 15, country: "USA" },      // 美国AT4火箭筒
    PF98_HE: { range: 800, explosionRadius: 25, country: "China" },     // 中国PF98高爆弹
    Panzerfaust3: { range: 600, explosionRadius: 20, country: "Germany" } // 德国铁拳3
}
};

    const weaponSettingsGroup = Array.from(document.querySelectorAll('#setupControls .controls-group')).find(group => {
        const h3 = group.querySelector('h3');
        return h3 && (h3.textContent === '武器設置' || h3.textContent.includes('武器') || h3.textContent.toLowerCase().includes('weapon'));
    });

    const bulletSettingsContainer = document.createElement('div');
    bulletSettingsContainer.className = 'controls-group';
    bulletSettingsContainer.innerHTML = `
        <h3>武器參數設置</h3>
        
        <div class="weapon-category">
            <h4>手槍設置</h4>
            <div class="controls-row">
                <label>手槍/狙擊槍類型:

<select id="pistolType">
    <optgroup label="手槍">
        <option value="default">預設手槍</option>
        <option value="glock17">Glock 17</option>
        <option value="desertEagle">沙漠之鷹</option>
        <option value="fn57">FN Five-seveN</option>
        <option value="beretta92">Beretta 92FS</option>
        <option value="sigSauerP226">SIG Sauer P226</option>
        <option value="cz75">CZ 75</option>
        <option value="usp45">H&K USP .45</option>
        <option value="makarov">Makarov PM</option>
        <option value="waltherPPK">Walther PPK</option>
        <option value="taurusPT92">Taurus PT92</option>
    </optgroup>
    <optgroup label="狙擊槍">
        <option value="awm">AWM</option>
        <option value="barrett">Barrett M82</option>
        <option value="m24">M24 SWS</option>
        <option value="svd">SVD Dragunov</option>
        <option value="l96a1">L96A1</option>
        <option value="cheytacM200">CheyTac M200</option>
        <option value="rem700">Remington 700</option>
        <option value="sr25">SR-25</option>
        <option value="m40a5">M40A5</option>
        <option value="tac50">McMillan Tac-50</option>
    </optgroup>
</select>
                </label>
            </div>
            <div class="controls-row">
                <label>射程: <input type="number" id="pistolRange" value="40" min="1" max="100"></label>
                <label>穿透: <input type="number" id="pistolPenetration" value="3" min="0" max="10"></label>
                <label>速度: <input type="number" id="pistolSpeed" value="0.2" min="0.1" max="1" step="0.01"></label>
            </div>
            <div class="controls-row">
                <label>彈匣容量: <input type="number" id="pistolMagazineSize" value="18" min="1" max="50"></label>
                <label>上彈時間 (秒): <input type="number" id="pistolReloadTime" value="1" min="0.1" max="5" step="0.1"></label>
            </div>
        </div>
        
        <div class="weapon-category">
            <h4>自動武器設置</h4>
            <div class="controls-row">
                <label>衝鋒槍/突擊步槍類型:
<select id="autoType">
    <optgroup label="衝鋒槍">
        <option value="default">預設衝鋒槍</option>
        <option value="mp5">MP5</option>
        <option value="p90">P90</option>
        <option value="ump45">UMP45</option>
        <option value="mac10">MAC-10</option>
        <option value="pp2000">PP-2000</option>
        <option value="mp7">MP7</option>
        <option value="skorpion">Skorpion vz. 61</option>
        <option value="uzi">Uzi</option>
        <option value="krissVector">KRISS Vector</option>
        <option value="mp9">MP9</option>
        </optgroup>
    <optgroup label="突擊步槍">
        <option value="m4">M4A1</option>
        <option value="ak47">AK-47</option>
        <option value="scarH">FN SCAR-H</option>
        <option value="g36">H&K G36</option>
        <option value="augA3">Steyr AUG A3</option>
        <option value="tar21">IWI Tavor TAR-21</option>
        <option value="famas">FAMAS</option>
        <option value="l85a2">L85A2</option>
        <option value="qbz95">QBZ-95</option>
        <option value="hk416">H&K HK416</option>
    </optgroup>
</select>

                </label>
            </div>
            <div class="controls-row">
                <label>射程: <input type="number" id="autoRange" value="12" min="1" max="100"></label>
                <label>穿透: <input type="number" id="autoPenetration" value="1" min="0" max="10"></label>
                <label>速度: <input type="number" id="autoSpeed" value="0.2" min="0.1" max="1" step="0.01"></label>
            </div>
            <div class="controls-row">
                <label>彈匣容量: <input type="number" id="autoMagazineSize" value="30" min="1" max="100"></label>
                <label>上彈時間 (秒): <input type="number" id="autoReloadTime" value="2" min="0.1" max="5" step="0.1"></label>
            </div>
        </div>
        
        <div class="weapon-category">
            <h4>散彈槍設置</h4>
            <div class="controls-row">
                <label>散彈槍類型:
                    <select id="shotgunType">
                        <option value="default">預設散彈槍</option>
                        <option value="m870">Remington M870</option>
                        <option value="aa12">AA-12</option>
                        <option value="saiga12">Saiga-12</option>
                        <option value="spas12">SPAS-12</option>
                        <option value="benelliM4">Benelli M4</option>
                        <option value="mossberg590">Mossberg 590</option>
                        <option value="ksg">Kel-Tec KSG</option>
                        <option value="m26">M26 MASS</option>
                        <option value="fabarm">FABARM STF 12</option>
                        <option value="usas12">USAS-12</option>
                    </select>
                </label>
            </div>
            <div class="controls-row">
                <label>射程: <input type="number" id="shotgunRange" value="6" min="1" max="100"></label>
                <label>穿透: <input type="number" id="shotgunPenetration" value="4" min="0" max="10"></label>
                <label>速度: <input type="number" id="shotgunSpeed" value="0.12" min="0.1" max="1" step="0.01"></label>
            </div>
            <div class="controls-row">
                <label>彈匣容量: <input type="number" id="shotgunMagazineSize" value="12" min="1" max="20"></label>
                <label>上彈時間 (秒): <input type="number" id="shotgunReloadTime" value="1.5" min="0.1" max="5" step="0.1"></label>
            </div>
        </div>
        
        <div class="weapon-category">
            <h4>手榴彈設置</h4>
            <div class="controls-row">
                <label>手榴彈類型:
                    <select id="grenadeType">
       <optgroup label="手榴弹">
            <option value="frag_M67">美国 M67破片手榴弹</option>
            <option value="frag_RGD5">俄罗斯 RGD-5</option>
            <option value="frag_Type82">中国 82式</option>
        </optgroup>
        
        <!-- 榴弹发射器 -->
        <optgroup label="榴弹发射器">
            <option value="GL_M433">美国 M433 HEDP</option>
            <option value="GL_GP25">俄罗斯 GP-25</option>
            <option value="GL_QLG10">中国 QLG10</option>
        </optgroup>
        
        <!-- 反坦克武器 -->
        <optgroup label="反坦克武器">
            <option value="RPG7_PG7VL">俄罗斯 RPG-7 (PG-7VL)</option>
            <option value="AT4_HEAT">美国 AT4火箭筒</option>
            <option value="PF98_HE">中国 PF98高爆弹</option>
            <option value="Panzerfaust3">德国 铁拳3</option>
        </optgroup>
                    </select>
                </label>
            </div>
            <div class="controls-row">
                <label>射程: <input type="number" id="grenadeRange" value="20" min="1" max="50"></label>
                <label>爆炸範圍: <input type="number" id="grenadeExplosionRadius" value="2" min="1" max="10"></label>
            </div>
        </div>
        
        <div class="controls-row">
            <button id="applyBulletSettings" class="primary-btn">應用武器設置</button>
        </div>
    `;

    if (weaponSettingsGroup) {
        weaponSettingsGroup.appendChild(bulletSettingsContainer);
    } else {
        console.warn('未找到武器設置控制組，將武器設置附加到 setupControls');
        setupControls.appendChild(bulletSettingsContainer);
        showStatusMessage('武器設置已附加到設置控制區域', 'info');
    }

    // 為每個武器類型添加事件監聽器
    document.getElementById('pistolType').addEventListener('change', function() {
        const type = this.value;
        const preset = weaponPresets.pistol[type] || weaponPresets.pistol.default;
        updateWeaponInputs('pistol', preset);
    });

    document.getElementById('autoType').addEventListener('change', function() {
        const type = this.value;
        const preset = weaponPresets.auto[type] || weaponPresets.auto.default;
        updateWeaponInputs('auto', preset);
    });

    document.getElementById('shotgunType').addEventListener('change', function() {
        const type = this.value;
        const preset = weaponPresets.shotgun[type] || weaponPresets.shotgun.default;
        updateWeaponInputs('shotgun', preset);
    });

    document.getElementById('grenadeType').addEventListener('change', function() {
        const type = this.value;
        const preset = weaponPresets.grenade[type] || weaponPresets.grenade.default;
        document.getElementById('grenadeRange').value = preset.range;
        document.getElementById('grenadeExplosionRadius').value = preset.explosionRadius;
    });

    // 更新武器輸入框的函數
    function updateWeaponInputs(prefix, preset) {
        document.getElementById(`${prefix}Range`).value = preset.range;
        document.getElementById(`${prefix}Penetration`).value = preset.penetration;
        document.getElementById(`${prefix}Speed`).value = preset.speed * globalWeaponSpeedMultiplier;
        if (preset.magazineSize) {
            document.getElementById(`${prefix}MagazineSize`).value = preset.magazineSize;
        }
        if (preset.reloadTime) {
            document.getElementById(`${prefix}ReloadTime`).value = preset.reloadTime;
        }
    }

    document.getElementById('applyBulletSettings').addEventListener('click', () => {
        try {
            bulletSettings.pistol = {
                range: parseFloat(document.getElementById('pistolRange').value) || 10,
                penetration: parseInt(document.getElementById('pistolPenetration').value) || 1,
                speed: parseFloat(document.getElementById('pistolSpeed').value) || 0.2,
                magazineSize: parseInt(document.getElementById('pistolMagazineSize').value) || 10,
                reloadTime: parseFloat(document.getElementById('pistolReloadTime').value) || 1
            };
            
            bulletSettings.auto = {
                range: parseFloat(document.getElementById('autoRange').value) || 10,
                penetration: parseInt(document.getElementById('autoPenetration').value) || 1,
                speed: parseFloat(document.getElementById('autoSpeed').value) || 0.2,
                magazineSize: parseInt(document.getElementById('autoMagazineSize').value) || 30,
                reloadTime: parseFloat(document.getElementById('autoReloadTime').value) || 2
            };
            
            bulletSettings.shotgun = {
                range: parseFloat(document.getElementById('shotgunRange').value) || 5,
                penetration: parseInt(document.getElementById('shotgunPenetration').value) || 3,
                speed: parseFloat(document.getElementById('shotgunSpeed').value) || 0.15,
                magazineSize: parseInt(document.getElementById('shotgunMagazineSize').value) || 6,
                reloadTime: parseFloat(document.getElementById('shotgunReloadTime').value) || 1.5
            };
            
            bulletSettings.grenade = {
                range: parseFloat(document.getElementById('grenadeRange').value) || 10,
                explosionRadius: parseFloat(document.getElementById('grenadeExplosionRadius').value) || 2
            };
             globalWeaponSpeedMultiplier = parseFloat(weaponSpeedMultiplierInput.value) || 0.5;
            if (isNaN(globalWeaponSpeedMultiplier)) {
                globalWeaponSpeedMultiplier = 0.5; // 確保不是 NaN
            }
            console.log("當前武器速度倍數:", globalWeaponSpeedMultiplier); // 調試
            showStatusMessage('武器設置已應用！', 'success');
        } catch (error) {
            console.error('應用武器設置錯誤:', error);
            showStatusMessage('應用武器設置失敗！', 'error');
        }
    });
}
// New function to draw background image
function drawBackgroundImage() {
    if (gameState === 'setup' && backgroundImage.img) {
        ctx.globalAlpha = 0.5; // Semi-transparent
        ctx.drawImage(
            backgroundImage.img,
            backgroundImage.x * cellSize,
            backgroundImage.y * cellSize,
            backgroundImage.width * cellSize,
            backgroundImage.height * cellSize
        );
        ctx.globalAlpha = 1.0; // Reset opacity
    }
}



startSetupBtn.addEventListener('click', handleStartSetup);

function handleStartSetup() {
    try {
        const newGridSize = parseInt(gridSizeInput.value);
        if (newGridSize < 10 || newGridSize > 2000 || isNaN(newGridSize)) {
            showStatusMessage('網格尺寸必須是10到2000之間的數字', 'error');
            return;
        }

              // 更新全局gridSize变量
        gridSize = newGridSize;  

        // 初始化游戏状态
        savedGrid = null;
        savedEnemies = null;
        savedDefenseAreas = null;
        savedPlayers = null;
        
        // 初始化网格和画布
        initGrid();
        resizeCanvas();

        
        const setupData = initializeSetupData(gridSize);
        setupGameState(setupData);
        initializeGameComponents(setupData);
        drawGrid();
        
    } catch (error) {
        handleSetupError(error);
    }
}

// 驗證網格尺寸
function validateGridSize() {
    const gridSize = parseInt(gridSizeInput.value);
    if (gridSize < 10 || gridSize > 2000 || isNaN(gridSize)) {
        showStatusMessage('網格尺寸必須是10到2000之間的數字', 'error');
        return null;
    }
    return gridSize;
}

// 初始化設置數據
function initializeSetupData(gridSize) {
    return {
        gridSize: gridSize,
        savedGrid: null,
        savedEnemies: null,
        savedDefenseAreas: null,
        savedPlayers: null,
        players: [],

        currentPlayerIndex: 0,
        settingEnemyPath: false,
        enemyPathPoints: [],
        ammoDepots: [], // 添加這行初始化彈藥庫陣列
        currentPathEnemy: null
    };
}

// 設置遊戲狀態
function setupGameState(setupData) {
    gameState = 'setup';
    isEditMode = true;
    setupControls.style.display = 'block';
    startSetupBtn.style.display = 'none';
    gridSizeInput.disabled = true;
    
    // 確保 setupData.ammoDepots 存在，如果沒有則初始化為空陣列
    const initialAmmoDepots = setupData.ammoDepots || [];
    
    // 更新全局變量
    Object.assign(window, {
        gridSize: setupData.gridSize,
        savedGrid: setupData.savedGrid,
        savedEnemies: setupData.savedEnemies,
        savedDefenseAreas: setupData.savedDefenseAreas,
        savedPlayers: setupData.savedPlayers,
        players: setupData.players,
        currentPlayerIndex: setupData.currentPlayerIndex,
        settingEnemyPath: setupData.settingEnemyPath,
        enemyPathPoints: setupData.enemyPathPoints,
        currentPathEnemy: setupData.currentPathEnemy,
        // 確保彈藥庫被正確初始化
        ammoDepots: initialAmmoDepots.map(depot => ({
            x: depot.x,
            y: depot.y,
            collected: depot.collected || false  // 確保 collected 屬性存在
        })),
        windows: setupData.windows || [],
        teleports: setupData.teleports || []
    });
    
    // 額外確保全局變量被設置（雙重保障）
    ammoDepots = window.ammoDepots;
    
    // 調試用：檢查彈藥庫是否正確初始化
    console.log('彈藥庫初始化完成，數量:', ammoDepots.length);
    console.log('彈藥庫內容:', ammoDepots);
}

// 初始化遊戲組件
function initializeGameComponents() {
    initGrid();
    resizeCanvas();
    initTeleportControls();
    createTeleportGroupSelector();
    initCompanionSystem();
}

// 處理設置錯誤
function handleSetupError(error) {
    console.error('開始設置錯誤:', error);
    showStatusMessage('開始設置時發生錯誤', 'error');
}

// 新增的初始化同伴系統函數
function initCompanionSystem() {
    // 重置所有同伴狀態
    players.forEach(player => {
        player.isCompanion = false;
        player.companionOf = null;
        player.companionTarget = null;
        player.companionState = 'idle';
    });
    
    // 初始化同伴控制按鍵
    keys.t = false;
    
    // 設置同伴事件監聽器
    setupCompanionControls();
}


// 新增的設置同伴控制函數
function setupCompanionControls() {
    // 移除舊的事件監聽器以避免重複綁定
    document.removeEventListener('keydown', handleCompanionKeyDown);
    document.removeEventListener('keyup', handleCompanionKeyUp);
    canvas.removeEventListener('mousedown', handleCompanionMouseDown);
    
    // 添加新的事件監聽器
    document.addEventListener('keydown', handleCompanionKeyDown);
    document.addEventListener('keyup', handleCompanionKeyUp);
    canvas.addEventListener('mousedown', handleCompanionMouseDown);
}

// 同伴鍵盤按下處理
function handleCompanionKeyDown(e) {
    if (gameState === 'playing') {
        if (e.key.toLowerCase() === 't') {
            keys.t = true;
            if (!mouseDown) {
                tryRecruitCompanion();
            }
        }
        
        // 添加Tab鍵切換玩家功能
        if (e.key === 'Tab') {
            e.preventDefault();
            switchToNextPlayer();
        }
    }
}
// 同伴鍵盤釋放處理
function handleCompanionKeyUp(e) {
    if (e.key.toLowerCase() === 't') {
        keys.t = false;
    }
}
// 同伴鼠標點擊處理
function handleCompanionMouseDown(e) {
    if (gameState === 'playing') {
        mouseDown = true;
        if (keys.t && e.button === 0) {
            commandCompanion(e);
        }
    }
}
// 切換到下一個玩家
function switchToNextPlayer() {
    const alivePlayers = players.filter(p => p.alive);
    if (alivePlayers.length <= 1) return;
    
    let newIndex = (currentPlayerIndex + 1) % players.length;
    
    // 尋找下一個存活玩家
    while (!players[newIndex].alive && newIndex !== currentPlayerIndex) {
        newIndex = (newIndex + 1) % players.length;
    }
    
    if (players[newIndex].alive) {
        currentPlayerIndex = newIndex;
        updateCamera(players[currentPlayerIndex]);
        updatePlayersDisplay();
        showStatusMessage(`現在控制玩家 ${currentPlayerIndex + 1}`, 'info');
    }
}
// 在鍵盤事件處理中添加切換玩家功能
document.addEventListener('keydown', (event) => {
    // 檢查事件目標是否為輸入框
    const isInputElement = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
    if (isInputElement) {
        return; // 如果在輸入框中，直接返回，不阻止默認行為
    }

    // 需要阻止默認行為的按鍵
    const preventDefaultKeys = ['tab', 'w', 'a', 's', 'd', 'f', 'g', 'x', '1', '2', '3', 'r', 'h', 'c', 'v', 'b', 'q', 'e', 't', 'escape', 'z','y'];
    if (preventDefaultKeys.includes(event.key.toLowerCase())) {
        event.preventDefault();
    }

    // 遊戲進行中處理
    if (gameState === 'playing' && players.length > 0 && players[currentPlayerIndex].alive) {
        const key = event.key.toLowerCase();
        switch (key) {
            case 'tab':
                switchToNextPlayer();
                break;
            case 't':
                keys.t = true;
                if (!mouseDown) {
                    tryRecruitCompanion();
                }
                break;
            case 'w':
                keys.w = true;
                break;
            case 'a':
                keys.a = true;
                break;
            case 's':
                keys.s = true;
                break;
            case 'd':
                keys.d = true;
                break;
            case 'f':
                openDoor();
                break;
            case 'g':
                aiming = true;
                throwGrenade(event);
                break;
            case 'x':
                keys.x = true;
                break;
            case '1':
                players[currentPlayerIndex].weaponMode = 1;
                weaponModeDisplay.textContent = '手槍';
                break;
            case '2':
                players[currentPlayerIndex].weaponMode = 2;
                weaponModeDisplay.textContent = '自動';
                break;
            case '3':
                players[currentPlayerIndex].weaponMode = 3;
                weaponModeDisplay.textContent = '散彈槍';
                break;
            case 'r':
                console.log("按下R鍵，嘗試裝彈...");
                console.log(`當前玩家狀態: 
                    武器模式: ${players[currentPlayerIndex].weaponMode}
                    當前彈藥: ${players[currentPlayerIndex].ammo}
                    總彈藥: ${players[currentPlayerIndex].totalAmmo}
                    是否正在裝彈: ${players[currentPlayerIndex].isReloading}`);
                reloadWeapon(players[currentPlayerIndex]);
                break;
            case 'h':
                testMode = !testMode;
                showStatusMessage(`測試模式 ${testMode ? '開啟' : '關閉'}`, 'info');
                drawGrid();
                break;
            case 'shift':
                keys.shift = true;
                break;
            case 'c':
                keys.c = true;
                break;
            case 'y':
                keys.y = true;
                break;

        }
    }

    // 設置模式處理
    if (gameState === 'setup') {
        const key = event.key.toLowerCase();
        switch (key) {
            case 'c':
                currentPlacement = 'window';
                settingEnemyPath = false;
                curveControlPoint = null;
                showStatusMessage('窗戶放置模式 - 點擊地圖放置窗戶 (按Shift可連續放置)', 'info');
                break;
            case 'v':
                currentPlacement = 'teleport';
                settingEnemyPath = false;
                curveControlPoint = null;
                showStatusMessage('傳送點放置模式 - 點擊地圖放置傳送點', 'info');
                break;
            case 'b':
                currentPlacement = 'door';
                settingEnemyPath = false;
                curveControlPoint = null;
                showStatusMessage('門放置模式 - 點擊地圖放置門', 'info');
                break;
            case 'q':
                const placePlayerBtn = document.getElementById('placePlayer');
                if (placePlayerBtn) placePlayerBtn.click();
                break;
            case 'w':
                const placeWallBtn = document.getElementById('placeWall');
                if (placeWallBtn) placeWallBtn.click();
                break;
            case 'e':
                const placeLineWallBtn = document.getElementById('placeLineWall');
                if (placeLineWallBtn) placeLineWallBtn.click();
                break;
            case 'r':
                const placeRectWallBtn = document.getElementById('placeRectWall');
                if (placeRectWallBtn) placeRectWallBtn.click();
                break;
            case 'f':
                const placeCurveWallBtn = document.getElementById('placeCurveWall');
                if (placeCurveWallBtn) placeCurveWallBtn.click();
                break;
            case 'a':
                const placeEnemyBtn = document.getElementById('placeEnemy');
                if (placeEnemyBtn) placeEnemyBtn.click();
                break;
            case 's':
                const placeZombieBtn = document.getElementById('placeZombie');
                if (placeZombieBtn) placeZombieBtn.click();
                break;
            case 'l':  // 新增 Licker 快捷键
                const placeLickerBtn = document.getElementById('placeLickerBtn');
                if (placeLickerBtn) placeLickerBtn.click();
                break;
            case 'x':
                const removeItemBtn = document.getElementById('removeItem');
                if (removeItemBtn) removeItemBtn.click();
                currentPlacement = 'remove';
                break;
            case 'z':
                const removeEntityBtn = document.getElementById('removeEntity');
                if (removeEntityBtn) removeEntityBtn.click();
                currentPlacement = 'removeEntity';
                break;
        }
    }

    // 退出放置模式
    switch (event.key) {
        case 'Escape':
            currentPlacement = null;
            showStatusMessage('退出放置模式', 'info');
            break;
    }
});

// 添加事件監聽器
placeAmmoDepotBtn.addEventListener('click', () => {
    currentPlacement = 'ammoDepot';
    settingEnemyPath = false;
    curveControlPoint = null;
});

        placePlayerBtn.addEventListener('click', () => {
            currentPlacement = 'player';
            settingEnemyPath = false;
            curveControlPoint = null;
        });

        placeWallBtn.addEventListener('click', () => {
            currentPlacement = 'wall';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        // 添加傳送點放置邏輯
placeTeleportBtn.addEventListener('click', () => {
    currentPlacement = 'teleport';
    settingEnemyPath = false;
    curveControlPoint = null;
    showStatusMessage('點擊地圖放置傳送點（相同顏色的點會互相傳送）', 'info');
});



        placeLineWallBtn.addEventListener('click', () => {
            currentPlacement = 'lineWall';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        placeCurveWallBtn.addEventListener('click', () => {
            currentPlacement = 'curveWall';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        placeRectWallBtn.addEventListener('click', () => {
            currentPlacement = 'rectWall';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        placeDoorBtn.addEventListener('click', () => {
            currentPlacement = 'door';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        placeWindowBtn.addEventListener('click', () => {
            currentPlacement = 'window';
            settingEnemyPath = false;
            curveControlPoint = null;
        });

        placeEnemyBtn.addEventListener('click', () => {
            currentPlacement = 'enemy';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        placeZombieBtn.addEventListener('click', () => {
            currentPlacement = 'zombie';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
placeLickerBtn.addEventListener('click', () => {
    currentPlacement = 'licker';
    settingEnemyPath = false;
    curveControlPoint = null;
    showStatusMessage('已選擇放置 Licker (按 L 鍵快速選擇)', 'info');
});
        placeDefenseAreaBtn.addEventListener('click', () => {
            currentPlacement = 'defenseArea';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        removeItemBtn.addEventListener('click', () => {
            currentPlacement = 'remove';
            settingEnemyPath = false;
            curveControlPoint = null;
        });

        removeEntityBtn.addEventListener('click', () => {
            currentPlacement = 'removeEntity';
            settingEnemyPath = false;
            curveControlPoint = null;
        });
        
        setEnemyPathBtn.addEventListener('click', () => {
            settingEnemyPath = !settingEnemyPath;
            if (settingEnemyPath) {
                setEnemyPathBtn.textContent = '完成路徑';
                enemyPathPoints = [];
                currentPathEnemy = null;
            } else {
                setEnemyPathBtn.textContent = '設置敵人路徑';
            }
            currentPlacement = null;
            curveControlPoint = null;
            drawGrid();
        });

        saveMapBtn.addEventListener('click', saveMap);
        loadMapBtn.addEventListener('click', loadMap);
        exportMapBtn.addEventListener('click', exportMap);
        importMapBtn.addEventListener('click', importMap);
        restartGameBtn.addEventListener('click', confirmRestart);




canvas.addEventListener('mousedown', (event) => {
    // 檢查事件目標是否為輸入框
    const isInputElement = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
    if (isInputElement) {
        return; // 如果在輸入框中，直接返回，不處理遊戲邏輯
    }

    const rect = canvas.getBoundingClientRect();
    const gridX = Math.floor((event.clientX - rect.left) / cellSize);
    const gridY = Math.floor((event.clientY - rect.top) / cellSize);

    if (gameState === 'playing') {
        handlePlayingModeMouseDown(event, gridX, gridY);
    } else if (gameState === 'setup') {
        if (currentPlacement === 'window' && event.shiftKey) {
            // 直線連續放置窗戶模式
            placeSingleWindow(gridX, gridY);

            let placeWindowLine;
            let stopWindowLine;

            placeWindowLine = (e) => {
                const x = Math.floor((e.clientX - rect.left) / cellSize);
                const y = Math.floor((e.clientY - rect.top) / cellSize);
                const cells = getLineCells(gridX, gridY, x, y);
                cells.forEach(cell => {
                    placeSingleWindow(cell.x, cell.y);
                });
            };

            stopWindowLine = () => {
                canvas.removeEventListener('mousemove', placeWindowLine);
                canvas.removeEventListener('mouseup', stopWindowLine);
            };

            canvas.addEventListener('mousemove', placeWindowLine);
            canvas.addEventListener('mouseup', stopWindowLine);
        } else {
            // 其他設置模式下的點擊處理
            handleSetupModeMouseDown(event, gridX, gridY);
        }
    }
});

// Helper functions
function getMouseGridPosition(event) {
    const rect = canvas.getBoundingClientRect();
    let x, y;
    
    if (isEditMode) {
        // 編輯模式：直接計算網格座標
        x = Math.floor((event.clientX - rect.left) / cellSize);
        y = Math.floor((event.clientY - rect.top) / cellSize);
    } else {
        // 遊戲模式：考慮攝像機偏移
        x = Math.floor((event.clientX - rect.left) / cellSize + cameraOffset.x);
        y = Math.floor((event.clientY - rect.top) / cellSize + cameraOffset.y);
    }
    
    return {x, y};
}

function handlePlayingModeMouseDown(event, x, y) {
    mouseDown = true;
    lastMousePos = { clientX: event.clientX, clientY: event.clientY };
    
    // 如果是T鍵+鼠標左鍵，指揮同伴
    if (keys.t && event.button === 0) {
        commandCompanion(event);
    } else if (event.button === 0) {
        shootBullet(event);
    }
    
    drawPlayerStatus();
}

function drawPlayerStatus() {
    // 只繪製當前玩家的狀態
    if (players.length > 0 && players[currentPlayerIndex].alive) {
        const player = players[currentPlayerIndex];
        const screenX = (player.x - cameraOffset.x) * cellSize;
        const screenY = (player.y - cameraOffset.y) * cellSize;
    
        // 只繪製數字狀態 (格式：彈藥/總彈藥/手榴彈)
        const ammoText = `${player.ammo}/${player.totalAmmo}/${player.grenadeCount}`;
        ctx.fillStyle = '#f1c40f'; // 黃色文字
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(ammoText, screenX, screenY - 15); // 頭頂上方15像素
    
        // 玩家角色繪製（帶旋轉）
        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.rotate(player.angle); // 使用更新後的角度
    
        // 玩家身體
        ctx.fillStyle = '#3498db';
        ctx.beginPath();
        ctx.arc(0, 0, cellSize / 2, 0, Math.PI * 2);
        ctx.fill();
    
        // 武器方向指示器
        ctx.strokeStyle = '#ecf0f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(cellSize / 2, 0);
        ctx.stroke();
        ctx.restore();

    }
    
    // 移除其他玩家或隊友的文字狀態繪製
    // 這裡原本可能有繪製其他玩家狀態的代碼，現在已經移除
}

function handleSetupModeMouseDown(event, x, y) {
    if (currentPlacement === 'wall' || currentPlacement === 'rectWall' || currentPlacement === 'defenseArea' || 
        currentPlacement === 'lineWall' || currentPlacement === 'curveWall' || currentPlacement === 'remove' || 
        currentPlacement === 'removeEntity') {
        handleWallPlacement(event, x, y);
    } else if (backgroundImage.img && !backgroundImage.isLocked) {
        handleBackgroundImageDrag(event, x, y);
    } else if (settingEnemyPath) {
        handleEnemyPathSetting(event, x, y);
    }
}

function handleWallPlacement(event, x, y) {
    if (currentPlacement === 'remove') {
        startDraggingRect(x, y);
    } else if (currentPlacement === 'removeEntity') {
        startDraggingRect(x, y);
    } else if (currentPlacement === 'curveWall') {
        handleCurveWallPlacement(event, x, y);
    } else if (currentPlacement === 'rectWall') {
        startDraggingRect(x, y);
    } else if (currentPlacement === 'defenseArea') {
        currentDefenseArea = { x: Math.floor(x), y: Math.floor(y), currentX: Math.floor(x), currentY: Math.floor(y) };
        isDragging = true;
    } else if (currentPlacement === 'lineWall') {
        startDraggingRect(x, y);
    } else if (isValidGridPosition(x, y)) {
        grid[Math.floor(y)][Math.floor(x)] = 'wall';
        drawGrid();
    }
}

function startDraggingRect(x, y) {
    isDragging = true;
    rectStart = { 
        x: Math.floor(x), 
        y: Math.floor(y), 
        currentX: Math.floor(x), 
        currentY: Math.floor(y) 
    };
}

function handleCurveWallPlacement(event, x, y) {
    if (curveDrawingState === 'none') {
        startDraggingRect(x, y);
        curveDrawingState = 'drawing_line';
    } else if (curveDrawingState === 'adjusting_curve') {
        const cells = getCurveCells(
            rectStart.x, 
            rectStart.y, 
            curveControlPoint.x, 
            curveControlPoint.y, 
            rectStart.currentX, 
            rectStart.currentY
        );
        
        cells.forEach(cell => {
            if (isValidGridPosition(cell.x, cell.y)) {
                grid[cell.y][cell.x] = 'wall';
            }
        });
        
        curveDrawingState = 'none';
        rectStart = null;
        curveControlPoint = null;
        isDragging = false;
        drawGrid();
    }
}

function isValidGridPosition(x, y) {
    return Math.floor(x) >= 0 && Math.floor(x) < gridSize && 
           Math.floor(y) >= 0 && Math.floor(y) < gridSize;
}

function handleBackgroundImageDrag(event, x, y) {
    // Check if click is within image bounds
    if (x >= backgroundImage.x && x <= backgroundImage.x + backgroundImage.width &&
        y >= backgroundImage.y && y <= backgroundImage.y + backgroundImage.height) {
        backgroundImage.isDragging = true;
        backgroundImage.dragStart = { 
            x: x - backgroundImage.x, 
            y: y - backgroundImage.y 
        };
    }
}

function handleEnemyPathSetting(event, x, y) {
    if (!currentPathEnemy) {
        findEnemyForPathSetting(x, y);
    } else {
        addPathPoint(x, y);
    }
}

function findEnemyForPathSetting(x, y) {
  // 先重置當前編輯的敵人（如果存在）
  if (currentPathEnemy) {
    currentPathEnemy.isBeingEdited = false; // 新增標記字段
  }

  // 尋找新敵人
  for (let i = 0; i < enemies.length; i++) {
    const enemy = enemies[i];
    const distance = Math.sqrt(Math.pow(enemy.x - (x + 0.5), 2) + 
                              Math.pow(enemy.y - (y + 0.5), 2));
    
    if (distance < 0.6) {
      currentPathEnemy = enemy;
      enemy.isBeingEdited = true; // 標記正在編輯
      enemyPathPoints = enemy.path ? [...enemy.path] : [{x, y}];
      
      // 視覺反饋：在敵人頭頂顯示編輯標記
      drawGrid();
      return;
    }
  }
  
  // 如果沒點中敵人，保持當前編輯對象不變
}

function addPathPoint(x, y) {
    // 確保當前敵人存在
    if (!currentPathEnemy) return;
    
    // 初始化路徑數組
    if (!currentPathEnemy.path) {
        currentPathEnemy.path = [];
    }
    
    // 添加新點
    enemyPathPoints.push({x, y});
    
    // 更新敵人的路徑
    currentPathEnemy.path = enemyPathPoints.map(p => ({...p}));
    
    // 重置路徑跟蹤狀態
    currentPathEnemy.currentPathIndex = undefined;
    currentPathEnemy.pathDirection = 1;
    currentPathEnemy.lastPathIndex = undefined;
    
    drawGrid();
}


// 添加全局鼠标位置跟踪
let mouseX = 0;
let mouseY = 0;

// Modified canvas mousemove event listener to update removal rectangle preview
canvas.addEventListener('mousemove', (event) => {
     updateMousePosition(event);
    const rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;
    
    if (gameState === 'playing') {
                // 更新玩家角度
        if (players.length > 0 && players[currentPlayerIndex].alive) {
            updatePlayerAngle(players[currentPlayerIndex]);
        }
        lastMousePos = { clientX: event.clientX, clientY: event.clientY };
        updateGrenadeTarget(event);
        if (mouseDown && players[currentPlayerIndex].weaponMode === 2 && 
            Date.now() - players[currentPlayerIndex].lastShotTime >= players[currentPlayerIndex].shootRate) {
            shootBullet(event);
        }
    } else if (gameState === 'setup') {
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / cellSize;
        const y = (event.clientY - rect.top) / cellSize;
        
        if (backgroundImage.isDragging && backgroundImage.dragStart) {
            backgroundImage.x = x - backgroundImage.dragStart.x;
            backgroundImage.y = y - backgroundImage.dragStart.y;
            drawGrid();
        } else if (currentPlacement === 'remove' && isDragging && rectStart) {
            rectStart.currentX = Math.floor(x);
            rectStart.currentY = Math.floor(y);
            drawGrid();
        } else if (currentPlacement === 'removeEntity' && isDragging && rectStart) {
            rectStart.currentX = Math.floor(x);
            rectStart.currentY = Math.floor(y);
            drawGrid();
        } else if (currentPlacement === 'rectWall' && isDragging && rectStart) {
            rectStart.currentX = Math.floor(x);
            rectStart.currentY = Math.floor(y);
            drawGrid();
        } else if (currentPlacement === 'defenseArea' && isDragging && currentDefenseArea) {
            currentDefenseArea.currentX = Math.floor(x);
            currentDefenseArea.currentY = Math.floor(y);
            drawGrid();
        } else if (currentPlacement === 'lineWall' && isDragging && rectStart) {
            rectStart.currentX = Math.floor(x);
            rectStart.currentY = Math.floor(y);
            drawGrid();
        } else if (currentPlacement === 'curveWall') {
            if (isDragging && curveDrawingState === 'drawing_line') {
                rectStart.currentX = Math.floor(x);
                rectStart.currentY = Math.floor(y);
                drawGrid();
            } else if (curveDrawingState === 'adjusting_curve' && rectStart) {
                curveControlPoint = { x, y };
                drawGrid();
            }
        }
    }
});

// New canvas wheel event listener for image scaling
canvas.addEventListener('wheel', (event) => {
    if (gameState === 'setup' && backgroundImage.img && !backgroundImage.isLocked) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / cellSize;
        const y = (event.clientY - rect.top) / cellSize;

        // Scale around the mouse position
        const scaleFactor = event.deltaY < 0 ? 1.1 : 0.9; // Zoom in/out
        const oldWidth = backgroundImage.width;
        const oldHeight = backgroundImage.height;
        backgroundImage.width *= scaleFactor;
        backgroundImage.height *= scaleFactor;

        // Adjust position to keep mouse point stationary
        backgroundImage.x = x - (x - backgroundImage.x) * (backgroundImage.width / oldWidth);
        backgroundImage.y = y - (y - backgroundImage.y) * (backgroundImage.height / oldHeight);

        // Prevent image from becoming too small
        if (backgroundImage.width < 1) backgroundImage.width = 1;
        if (backgroundImage.height < 1) backgroundImage.height = 1;

        drawGrid();
    }
});

// Modified canvas mouseup event listener to handle curve wall line completion
// Modified canvas mouseup event listener to clear items in the selected rectangle
canvas.addEventListener('mouseup', (event) => {


    if (gameState === 'setup' && currentPlacement === 'remove' && isDragging && rectStart) {
        const rect = getRectCoords();
        
        // 移除網格物品
        for (let y = rect.y; y < rect.y + rect.height; y++) {
            for (let x = rect.x; x < rect.x + rect.width; x++) {
                if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                    grid[y][x] = 'empty';
                }
            }
        }
        
        // 新增：移除在矩形範圍內的傳送點
        teleports = teleports.filter(tp => 
            tp.x < rect.x || tp.x >= rect.x + rect.width ||
            tp.y < rect.y || tp.y >= rect.y + rect.height
        );
        
        rectStart = null;
        isDragging = false;
        drawGrid();
    }
    if (gameState === 'playing') {
        mouseDown = false;
    } else if (gameState === 'setup') {
        if (currentPlacement === 'remove' && isDragging && rectStart) {
            const rect = getRectCoords();
            for (let y = rect.y; y < rect.y + rect.height; y++) {
                for (let x = rect.x; x < rect.x + rect.width; x++) {
                    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                        grid[y][x] = 'empty';
                    }
                }
            }
            rectStart = null;
            isDragging = false;
            drawGrid();
        } else if (currentPlacement === 'removeEntity' && isDragging && rectStart) {
            const rect = getRectCoords();
            console.log('Removing entities in rect:', rect); // 調試：確認範圍
            enemies = enemies.filter(enemy => {
                const ex = enemy.x; // 使用原始坐標，考慮小數
                const ey = enemy.y;
                const inRect = ex >= rect.x && ex < rect.x + rect.width && ey >= rect.y && ey < rect.y + rect.height;
                if (inRect) console.log('Removing enemy:', enemy); // 調試：確認移除的敵人
                return !inRect;
            });
            players = players.filter(player => {
                const px = player.x; // 使用原始坐標，考慮小數
                const py = player.y;
                const inRect = px >= rect.x && px < rect.x + rect.width && py >= rect.y && py < rect.y + rect.height;
                if (inRect) console.log('Removing player:', player); // 調試：確認移除的玩家
                return !inRect;
            });
            console.log('After removal - Players:', players, 'Enemies:', enemies); // 調試：確認最終狀態
            if (currentPlayerIndex >= players.length) {
                currentPlayerIndex = players.length > 0 ? 0 : -1;
            }
            rectStart = null;
            isDragging = false;
            drawGrid();
            showStatusMessage('已移除選定範圍內的人物！', 'success');
        } else if (currentPlacement === 'rectWall' && isDragging && rectStart) {
            const rect = getRectCoords();
            for (let y = rect.y; y < rect.y + rect.height; y++) {
                for (let x = rect.x; x < rect.x + rect.width; x++) {
                    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                        if (x === rect.x || x === rect.x + rect.width - 1 || 
                            y === rect.y || y === rect.y + rect.height - 1) {
                            grid[y][x] = 'wall';
                        }
                    }
                }
            }
            rectStart = null;
            isDragging = false;
            drawGrid();
        } else if (currentPlacement === 'defenseArea' && isDragging && currentDefenseArea) {
            const rect = getRectCoords(currentDefenseArea);
            defenseAreas.push({ x: rect.x, y: rect.y, width: rect.width, height: rect.height });
            currentDefenseArea = null;
            isDragging = false;
            drawGrid();
        } else if (currentPlacement === 'lineWall' && isDragging && rectStart) {
            const cells = getLineCells(rectStart.x, rectStart.y, rectStart.currentX, rectStart.currentY);
            cells.forEach(cell => {
                if (cell.x >= 0 && cell.x < gridSize && cell.y >= 0 && cell.y < gridSize) {
                    grid[cell.y][cell.x] = 'wall';
                }
            });
            rectStart = null;
            isDragging = false;
            drawGrid();
        } else if (currentPlacement === 'curveWall' && isDragging && curveDrawingState === 'drawing_line') {
            isDragging = false;
            curveDrawingState = 'adjusting_curve';
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / cellSize);
            const y = Math.floor((event.clientY - rect.top) / cellSize);
            rectStart.currentX = x;
            rectStart.currentY = y;
            curveControlPoint = { x: (rectStart.x + x) / 2, y: (rectStart.y + y) / 2 };
            drawGrid();
        }
        if (backgroundImage.isDragging) {
            backgroundImage.isDragging = false;
            backgroundImage.dragStart = null;
        }
    }
});




canvas.addEventListener('mouseup', (e) => {
    mouseDown = false;
});

// 在招募新同伴時重置命令索引
function tryRecruitCompanion() {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || !currentPlayer.alive) return;
    
    // 尋找附近的玩家
    for (let i = 0; i < players.length; i++) {
        if (i === currentPlayerIndex || !players[i].alive || players[i].isCompanion) continue;
        
        const dist = Math.sqrt((players[i].x - currentPlayer.x) ** 2 + 
                              (players[i].y - currentPlayer.y) ** 2);
        
        // 如果距離足夠近且視線無阻擋
        if (dist <= 2 && hasLineOfSight(currentPlayer.x, currentPlayer.y, 
                                       players[i].x, players[i].y)) {
            // 招募為同伴
            players[i].isCompanion = true;
            players[i].companionOf = currentPlayer;
            players[i].companionTarget = null;
            
            // 重置命令索引
            currentCompanionCommandIndex = 0;
            
            showStatusMessage(`已招募玩家 ${i+1} 為同伴!`, 'success');
            break;
        }
    }
}
function commandCompanion(event) {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || !currentPlayer.alive) return;
    
    // 計算點擊位置的世界坐標
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    
    const worldX = (mouseX / cellSize) + cameraOffset.x;
    const worldY = (mouseY / cellSize) + cameraOffset.y;
    
    // 獲取當前玩家的所有活著的同伴（直接跟隨玩家的）
    const directCompanions = players.filter(p => 
        p.isCompanion && 
        p.companionOf === currentPlayer && 
        p.alive
    );
    
    // 如果沒有同伴則返回
    if (directCompanions.length === 0) return;
    
    // 如果只有一個直接同伴，保持原有行為
    if (directCompanions.length === 1) {
        directCompanions[0].companionTarget = { x: worldX, y: worldY };
        showStatusMessage(`已命令同伴前往 (${Math.floor(worldX)}, ${Math.floor(worldY)})`, 'info');
        return;
    }
    
    // 多個直接同伴時，按順序分配目標位置
    const targetCompanion = directCompanions[currentCompanionCommandIndex];
    targetCompanion.companionTarget = { x: worldX, y: worldY };
    
    // 標記這個同伴有獨立目標（非跟隨狀態）
    targetCompanion.hasIndependentTarget = true;
    
    showStatusMessage(`已命令同伴 ${currentCompanionCommandIndex + 1}/${directCompanions.length} 前往 (${Math.floor(worldX)}, ${Math.floor(worldY)})`, 'info');
    
    // 更新索引，準備為下一個同伴分配位置
    currentCompanionCommandIndex = (currentCompanionCommandIndex + 1) % directCompanions.length;
}


        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });


canvas.addEventListener('click', (e) => {
    if (gameState !== 'setup') return;
    
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / cellSize);
    const y = Math.floor((e.clientY - rect.top) / cellSize);
    
    if (currentPlacement === 'window') {
        placeSingleWindow(x, y);
    }
        if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

    if (currentPlacement === 'teleport') {
        placeTeleport(x, y);
    } else if (currentPlacement === 'door') {
        grid[y][x] = 'door';
        drawGrid();
    }
    
});

canvas.addEventListener('click', (event) => {
    const rect = canvas.getBoundingClientRect();
    let x, y;
    
    if (isEditMode) {
        // 編輯模式：直接計算網格座標
        x = Math.floor((event.clientX - rect.left) / cellSize);
        y = Math.floor((event.clientY - rect.top) / cellSize);
    } else {
        // 遊戲模式：考慮攝像機偏移
        x = Math.floor((event.clientX - rect.left) / cellSize + cameraOffset.x);
        y = Math.floor((event.clientY - rect.top) / cellSize + cameraOffset.y);
    }

    if (gameState === 'setup') {
        if (currentPlacement === 'teleport') {
            placeTeleport(x, y);
            drawGrid();
        } // <-- 這裡缺少了 else 或直接開始 switch 語句

        switch(currentPlacement) {
            case 'player':
                const newPlayer = createPlayer(x + 0.5, y + 0.5);
                players.push(newPlayer);
                if (players.length === 1) currentPlayerIndex = 0;
                break;
                
            case 'enemy':
                enemies.push({ x: x + 0.5, y: y + 0.5, type: 'enemy' });
                break;
                
            case 'zombie':
                enemies.push({ x: x + 0.5, y: y + 0.5, type: 'zombie' });
                break;
            case 'licker':  // 修正為小寫，與 setPlacementMode 保持一致
                enemies.push({ x: x + 0.5, y: y + 0.5, type: 'licker' ,    tongue: null, // 新增舌頭狀態
    tongueCooldown: 0});
            break;
                break;
                
            case 'window':
                if (!windows.some(w => Math.floor(w.x) === x && Math.floor(w.y) === y)) {
                    windows.push(createWindow(x, y));
                    showStatusMessage(`窗戶已放置在 (${x}, ${y})`, 'success');
                } else {
                    showStatusMessage('此位置已有窗戶', 'error');
                }
                break;
            case 'ammoDepot':
                if (!ammoDepots.some(d => Math.floor(d.x) === x && Math.floor(d.y) === y)) {
                    ammoDepots.push(createAmmoDepot(x, y));
                    showStatusMessage(`彈藥庫已放置在 (${x}, ${y})`, 'success');
                } else {
                    showStatusMessage('此位置已有彈藥庫', 'error');
                }
                break;

                
            case 'wall':
                grid[y][x] = 'wall';
                break;
                
            case 'door':
                grid[y][x] = 'door';
                break;
                
            case 'remove':
                grid[y][x] = 'empty';
                enemies = enemies.filter(enemy => Math.floor(enemy.x) !== x || Math.floor(enemy.y) !== y);
                players = players.filter(player => Math.floor(player.x) !== x || Math.floor(player.y) !== y);
                windows = windows.filter(win => Math.floor(win.x) !== x || Math.floor(win.y) !== y);
                break;
                
            case 'removeEntity':
                enemies = enemies.filter(enemy => Math.floor(enemy.x) !== x || Math.floor(enemy.y) !== y);
                players = players.filter(player => Math.floor(player.x) !== x || Math.floor(player.y) !== y);
                break;
                
            case 'teleport':
                const existing = teleports.find(tp => tp.x === x && tp.y === y);
                if (existing) {
                    showStatusMessage('此位置已有傳送點!', 'error');
                    return;
                }
                
                // 如果有選中的傳送點組，就加入該組
                if (selectedTeleportGroup !== null) {
                    teleports.push({
                        x: x,
                        y: y,
                        color: selectedTeleportGroup.color,
                        pairId: selectedTeleportGroup.pairId
                    });
                    showStatusMessage(`傳送點已添加到組 ${selectedTeleportGroup.pairId}`, 'success');
                } else {
                    // 創建新傳送組
                    const newPairId = Date.now();
                    const newColor = getRandomFluorescentColor();
                    teleports.push({
                        x: x,
                        y: y,
                        color: newColor,
                        pairId: newPairId
                    });
                    selectedTeleportGroup = { pairId: newPairId, color: newColor };
                    showStatusMessage(`創建新傳送組 ${newPairId}`, 'success');
                }
                break;
        } // <-- switch 語句結束
        
        drawGrid();
    } // <-- if (gameState === 'setup') 結束
}); // <-- 事件監聽器結束


// 檢查玩家是否接觸彈藥庫
function checkAmmoDepotCollision() {
    if (gameState !== 'playing') return;
    
    const player = players[currentPlayerIndex];
    if (!player || !player.alive) return;
    
    // 檢查玩家是否接觸任何彈藥庫
    ammoDepots.forEach(depot => {
        if (!depot.collected && 
            Math.floor(depot.x) === Math.floor(player.x) && 
            Math.floor(depot.y) === Math.floor(player.y)) {
            
            // 補充彈藥
            player.totalAmmo += 100;
            depot.collected = true;
            
            // 顯示提示信息
            showStatusMessage('獲得100發彈藥補給！', 'success');
            
            // 更新玩家顯示
            updatePlayersDisplay();
            

        }
    });
    
    // 移除已收集的彈藥庫
    ammoDepots = ammoDepots.filter(depot => !depot.collected);
}


function placeSingleWindow(x, y) {
    // 检查是否已有窗户在该位置
    const existingWindow = windows.find(w => w.x === x && w.y === y);
    
    if (!existingWindow) {
        windows.push(createWindow(x, y));
        // 如果该位置是墙，则移除墙
        if (grid[y][x] === 'wall') {
            grid[y][x] = 'empty';
        }
        showStatusMessage(`窗戶已放置在 (${x}, ${y})`, 'success');
    } else {
        showStatusMessage('此位置已有窗戶', 'error');
    }
    drawGrid();
}

// 創建彈藥庫對象
function createAmmoDepot(x, y) {
    return {
        x: x,
        y: y,
        collected: false
    };
}


// 繪製彈藥庫
function drawAmmoDepot(depot) {
    if (depot.collected) return;
    
    let screenX, screenY;
    
    if (isEditMode) {
        screenX = depot.x * cellSize;
        screenY = depot.y * cellSize;
    } else {
        screenX = (depot.x - cameraOffset.x) * cellSize;
        screenY = (depot.y - cameraOffset.y) * cellSize;
    }
    
    // 繪製彈藥箱陰影
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(screenX + cellSize*0.25, screenY + cellSize*0.2, cellSize*0.6, cellSize*0.7);
    
    // 繪製彈藥箱主體
    ctx.fillStyle = 'rgba(200, 160, 60, 0.9)';
    ctx.fillRect(screenX + cellSize*0.2, screenY + cellSize*0.1, cellSize*0.6, cellSize*0.7);
    
    // 繪製彈藥箱邊框
    ctx.strokeStyle = 'rgba(100, 80, 30, 0.9)';
    ctx.lineWidth = 2;
    ctx.strokeRect(screenX + cellSize*0.2, screenY + cellSize*0.1, cellSize*0.6, cellSize*0.7);
    
    // 繪製彈藥箱細節
    ctx.fillStyle = 'rgba(150, 120, 40, 0.9)';
    ctx.fillRect(screenX + cellSize*0.25, screenY + cellSize*0.15, cellSize*0.5, cellSize*0.1);
    
    // 繪製彈藥標誌
    ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
    ctx.beginPath();
    ctx.arc(screenX + cellSize*0.5, screenY + cellSize*0.5, cellSize*0.2, 0, Math.PI * 2);
    ctx.fill();
    
    // 繪製數字
    ctx.fillStyle = 'white';
    ctx.font = `bold ${cellSize*0.3}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('100', screenX + cellSize*0.5, screenY + cellSize*0.5);
}
// 繪製所有彈藥庫
function drawAmmoDepots() {
    ammoDepots.forEach(depot => {
        if (!depot.collected) {
            drawAmmoDepot(depot);
        }
    });
}



// 新增選擇傳送點組按鈕
function createTeleportGroupSelector() {
    const selector = document.createElement('div');
    selector.id = 'teleportGroupSelector';
    selector.style.margin = '10px';
    
    const label = document.createElement('label');
    label.textContent = '當前傳送組: ';
    selector.appendChild(label);
    
    const select = document.createElement('select');
    select.id = 'teleportGroupSelect';
    selector.appendChild(select);
    
    const refreshBtn = document.createElement('button');
    refreshBtn.textContent = '刷新列表';
    refreshBtn.onclick = refreshTeleportGroups;
    selector.appendChild(refreshBtn);
    
    document.getElementById('controls').appendChild(selector);
    refreshTeleportGroups();
}

function refreshTeleportGroups() {
    const select = document.getElementById('teleportGroupSelect');
    select.innerHTML = '';
    
    // 添加"新建組"選項
    const newOption = document.createElement('option');
    newOption.value = 'new';
    newOption.textContent = '-- 新建傳送組 --';
    select.appendChild(newOption);
    
    // 添加現有傳送組
    const groups = [...new Set(teleports.map(tp => tp.pairId))];
    groups.forEach(id => {
        const group = teleports.find(tp => tp.pairId === id);
        const option = document.createElement('option');
        option.value = id;
        option.textContent = `組 ${id.toString().slice(-3)} (${teleports.filter(tp => tp.pairId === id).length}個點)`;
        option.style.color = group.color;
        select.appendChild(option);
    });
    
    select.onchange = function() {
        if (this.value === 'new') {
            selectedTeleportGroup = null;
        } else {
            const group = teleports.find(tp => tp.pairId === parseInt(this.value));
            selectedTeleportGroup = { pairId: group.pairId, color: group.color };
        }
    };
}
function createTeleport(x, y, pairId) {
    return {
        x: x,
        y: y,
        color: getRandomFluorescentColor(),
        pairId: pairId || Date.now() // 如果沒有提供pairId，則創建新的
    };
}
// Modified keydown event listener to handle grenade aiming and throwing


// Modified keyup event listener to handle grenade throw on release
document.addEventListener('keyup', (event) => {
    if (gameState === 'playing') {
            if (event.key.toLowerCase() === 't') {
        keys.t = false;
    }
        switch (event.key.toLowerCase()) {
            case 'w': keys.w = false; break;
            case 'a': keys.a = false; break;
            case 's': keys.s = false; break;
            case 'd': keys.d = false; break;
            case 'y': keys.y = false; break;
            case 'g':
                if (grenade && !grenade.thrown) {
                    const player = players[currentPlayerIndex];
                    const dist = Math.sqrt(
                        (grenade.targetX - player.x) ** 2 + 
                        (grenade.targetY - player.y) ** 2
                    );
                    if (dist < 0.1 || isNaN(grenade.targetX) || isNaN(grenade.targetY)) {
                        console.log('Invalid grenade target, cancelling throw');
                        grenade = null;
                        aiming = false;
                    } else {
                        grenade.thrown = true;
                        aiming = false;
                    }
                }
                break;
            case 'x': 
                keys.x = false; 
                break;
            case 'shift':
                keys.shift = false;
                if (players[currentPlayerIndex]) {
                    players[currentPlayerIndex].isSprinting = false;
                }
                break;
            case 'c':
                keys.c = false;
                break;

        }
    }
});

        // Modified startGameBtn event listener to ensure ammo initialization
// 遊戲初始化相關函數
function initializeGameState() {
    // 1. 檢查是否有玩家
    validatePlayers();
    
    // 2. 保存遊戲初始狀態
    saveInitialGameState();
    
    // 3. 重置玩家狀態
    resetPlayersState();
    
    // 4. 更新武器設置
    updateWeaponSettings();
    
    // 5. 設置當前玩家
    setCurrentPlayer(0);
    
    // 6. 初始化敵人路徑
    initializeEnemiesPath();


        if (!grid || grid.length !== gridSize || grid[0].length !== gridSize) {
        console.error("Invalid grid dimensions!");
        // 重建 grid
        grid = Array(gridSize).fill().map(() => Array(gridSize).fill('empty'));
    }
    
    // 7. 設置遊戲狀態
    setGameState('playing');
    
    // 8. 更新UI
    updateGameUI();
    
    // 9. 調整畫布並開始遊戲
    startGameLoop();
}

// 驗證玩家是否存在
function validatePlayers() {
    if (players.length === 0) {
        showStatusMessage('請先放置至少一名玩家!', 'error');
        throw new Error('沒有玩家');
    }
    console.log("開始遊戲按鈕被點擊");
    console.log("當前玩家數量:", players.length);
}

// 保存初始遊戲狀態
function saveInitialGameState() {
    savedGrid = grid.map(row => [...row]);
    savedEnemies = JSON.parse(JSON.stringify(enemies));
    savedDefenseAreas = JSON.parse(JSON.stringify(defenseAreas));
}

// 重置玩家狀態
function resetPlayersState() {
    // 保存原始玩家位置
    const originalPlayerPositions = players.map(p => ({x: p.x, y: p.y}));
    
    // 清空玩家陣列
    players.length = 0;
    
    // 根據原始位置重新創建玩家（保持相同數量）
    originalPlayerPositions.forEach(pos => {
        const newPlayer = createPlayer(pos.x, pos.y);
        // 繼承武器設置
        newPlayer.ammo = parseInt(magazineSizeInput.value) || 10;
        newPlayer.totalAmmo = parseInt(totalAmmoInput.value) || 50;
        newPlayer.grenadeCount = parseInt(document.getElementById('grenadeCount').value) || 3;
        newPlayer.magazineSize = getMagazineSizes();
        newPlayer.reloadTime = getReloadTimes();
        players.push(newPlayer);
    });
    
    savedPlayers = JSON.parse(JSON.stringify(players));
}
// 獲取彈匣大小設置
function getMagazineSizes() {
    return {
        pistol: parseInt(document.getElementById('pistolMagazineSize').value) || 10,
        auto: parseInt(document.getElementById('autoMagazineSize').value) || 30,
        shotgun: parseInt(document.getElementById('shotgunMagazineSize').value) || 6
    };
}

// 獲取重新裝填時間
function getReloadTimes() {
    return {
        pistol: parseFloat(document.getElementById('pistolReloadTime').value) || 1.0,
        auto: parseFloat(document.getElementById('autoReloadTime').value) || 2.0,
        shotgun: parseFloat(document.getElementById('shotgunReloadTime').value) || 1.5
    };
}

// 更新武器設置
function updateWeaponSettings() {
    const reloadTimes = getReloadTimes();
    bulletSettings.pistol.reloadTime = reloadTimes.pistol;
    bulletSettings.auto.reloadTime = reloadTimes.auto;
    bulletSettings.shotgun.reloadTime = reloadTimes.shotgun;
    bulletSettings.grenadeRange = parseFloat(document.getElementById('grenadeRange').value) || 10;
    bulletSettings.grenadeExplosionRadius = parseFloat(document.getElementById('grenadeExplosionRadius').value) || 2;
}

// 設置當前玩家
function setCurrentPlayer(index) {
    currentPlayerIndex = index;
    console.log("遊戲開始時玩家數量:", players.length);
    console.log("玩家位置:", players.map(p => `(${p.x},${p.y})`).join(", "));
    
    // 初始化鼠標位置（玩家右側）
    if (players.length > 0) {
        mouseX = players[currentPlayerIndex].x * cellSize + 50;
        mouseY = players[currentPlayerIndex].y * cellSize;
    }
}

// 初始化敵人路徑
function initializeEnemiesPath() {
    enemies.forEach(enemy => {
        if (enemy.path && enemy.path.length > 0) {
            enemy.currentPathIndex = 0;
            enemy.patrolDirection = 1;
            enemy.x = enemy.path[0].x + 0.5;
            enemy.y = enemy.path[0].y + 0.5;
        }
    });
}

// 設置遊戲狀態
function setGameState(state) {
    gameState = state;
    isEditMode = state !== 'playing';
}

// 更新遊戲UI
function updateGameUI() {
    updateAmmoDisplay();
    updatePlayersDisplay();
    
    setupControls.style.display = isEditMode ? 'block' : 'none';
    weaponInfo.style.display = isEditMode ? 'none' : 'block';
    playerInfo.style.display = isEditMode ? 'none' : 'block';
}

// 開始遊戲循環
function startGameLoop() {
    resizeCanvas();
        enemies.forEach(enemy => {
        if (!enemy.path || enemy.path.length === 0) {
            // 創建一個包含當前位置的簡單路徑
            enemy.path = [
                {x: Math.floor(enemy.x), y: Math.floor(enemy.y)},
                {x: Math.floor(enemy.x) + 1, y: Math.floor(enemy.y)}
            ];
        }
    });
    updateGame();
}

// 事件監聽器
startGameBtn.addEventListener('click', () => {
    try {
        initializeGameState();
        
    } catch (error) {
        console.error('开始游戏错误:', error);
        showStatusMessage('开始游戏时发生错误: ' + error.message, 'error');
    }
});
        initGrid();
        resizeCanvas();
        drawGrid();
    </script>
</body>
</html>